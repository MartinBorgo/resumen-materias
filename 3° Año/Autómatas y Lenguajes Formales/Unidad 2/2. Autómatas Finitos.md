
Los estados son el √∫nico medio que disponen los AF para recordar los eventos que ocurren. Estos automatas se pueden dividir en:

1. Aut√≥matas Finitos Deterministas (AFD).
2. Aut√≥matas Finitos No Deterministas (AFN).

Estos automatas pueden ser representados mediante el ***modelo de sistemas discretos***, con este modelo se trata de representar la realidad continua de forma sencilla, para que estos modelos cumplan correctamente su funci√≥n deben tenerse en cuenta que modelo o situaci√≥n se est√° representando y si lo hace correctamente.
En los modelos de sistemas discretos, los estados y las transiciones deben estar bien distinguidos. 

>[!note] Nota
>Para este tipo de aut√≥matas los estados son excluyentes, lo que significa que solo se puede tener un estado u otro, no ambos al mismo tiempo.

---

# Aut√≥matas Finitos Deterministas


>[!important] El determinismo en los Aut√≥matas Finitos
>Un aut√≥mata finito puede ser determinista si, para cada estado y cada s√≠mbolo de entrada, existe una transici√≥n √∫nica a otro estado. Es decir, dado un estado y un s√≠mbolo de entrada, el aut√≥mata determinista siempre sabe exactamente a qu√© estado debe moverse a continuaci√≥n, sin necesidad de tomar decisiones o elegir entre varias opciones.
>Esta caracter√≠stica de un ***aut√≥mata finito determinista*** lo hace m√°s f√°cil de implementar y analizar, ya que su comportamiento est√° completamente determinado por su estructura y funci√≥n de transici√≥n.

Caracter√≠sticas:
- Solo se puede estar en un √∫nico estado luego de leer una entrada.
- Para cada entrada solo existe uno y solo un estado al que el aut√≥mata puede hacer la transici√≥n a partir del estado actual (determinismo).
- Presentan estados ‚Äúsaturados‚Äù, que sea saturado, significa que para cada estado, debe existir una transici√≥n para cada s√≠mbolo del alfabeto que procesa.

>[!info] Dato
>Este tipo de aut√≥matas son reconocedores de lenguajes.

A su vez, estos automatas pueden ser representados como una qu√≠ntupla ***A = (Q, Œ£, Œ¥, q0, F)*** en donde:

- ***Q*** es un conjunto finito no vac√≠o de estados.
- ***Œ£*** es el conjunto finito de s√≠mbolos de entrada.
- ***Œ¥: Q x Œ£ -> Q*** es la funci√≥n de transici√≥n.
- ***q0 ‚àà Q*** es el estado inicial.
- ***F ‚äÜ Q*** es el conjunto de estados finales.

#### Representaci√≥n de AFD

Estos se pueden representar de dos maneras, mediante un diagrama de transiciones (grafo) o una tabla de transiciones (matriz), cualquiera de los dos son pr√°cticas, a continuaci√≥n un ejemplo de ambas representaciones:

<span class="centerImg"> ![[ALF-AFD.png]] </span>

Con el fin de mostrar un ejemplo m√°s amplio que muestre todos los componentes de este tipo de aut√≥matas, le ponemos una imagen m√°s representativa.

<span class="centerImg"> ![[ALF-AFD2.png]] </span>

#### Dise√±o de AFD

A la hora de dise√±ar un AFD que sirva para la aceptaci√≥n de un lenguaje, se presentan dos posibles problemas:

1. **Soluci√≥n Incorrecta** -> Que sobren palabras en las sentencias
2. **Soluci√≥n Incompleta** -> Que falten palabras en las sentencias

Por eso, para dise√±ar uno de la manera m√°s correcta se deben crear estados intermedios que "recuerden" condiciones importantes en el problema que se busca solucionar. A su vez, proponer transiciones que permitan pasar de un estado a otro.
Para facilitar esta parte existen dos m√©todos de dise√±o

1. **Por Conjuntos de Estados** -> En este m√©todo asociamos condiciones a grupos de estados, con lo que logramos aumentar el grado de abstracci√≥n. Por Ej.:

<span class="centerImg"> ![[ALF-dise√±o-conjunto-estados.png]] </span>

>Como podemos ver, primero se crean grupos abstractos que representan una situaci√≥n particular y luego se intenta representar esos grupos mediante estados y transiciones que favorezcan esa representaci√≥n.

2. **Por Complemento** -> Al igual que el modelo anterior, se asocia las condiciones que una determinada cadena a grupos, con la particularidad que luego los estados que representan la situaci√≥n son invertidos. V√©ase el ejemplo:

<span class="centerImg"> ![[ALF-dise√±o-complemento.png]] </span>

## Reconocimiento de Palabras

Como ya hemos nombrado anteriormente, estos aut√≥matas en particular son reconocedores de lenguajes, ellos reciben una cadena de caracteres y determinan si pertenece o no al lenguaje, todo eso siguiendo los siguientes pasos

1. El AFD comienza en el estado inicial con el primer s√≠mbolo de la palabra y transita al siguiente estado.
2. A partir del estado en que qued√≥, transita a un nuevo estado al recibir como entrada el s√≠mbolo siguiente.
3. Despu√©s de procesar el √∫ltimo s√≠mbolo de la cadena de entrada, el AFD ha alcanzado cierto estado. Si dicho estado es final, la palabra se considera aceptada. En caso contrario, se considera rechazada.

#### Extensi√≥n de la Funci√≥n de Transici√≥n

A partir de la funci√≥n de transici√≥n de un AFD compuesta de la siguiente manera -> ***ùõø(ùëû, ùëé)/ùëé ‚àà ‚àë***. Se puede definir otra funci√≥n denominada funci√≥n de transici√≥n extendida, la cual se puede definir formalmente de forma recursiva:

<span class="centerImg"> ![[ALF-definicion-recursiva.png]] </span>

>[!important] Sobre la Funci√≥n de Transici√≥n Extendida
>La extensi√≥n de la funci√≥n de transici√≥n se refiere a la posibilidad de extender esta funci√≥n de transici√≥n a cadenas de s√≠mbolos del alfabeto de entrada, de tal forma que se pueda obtener el estado final en el que deber√≠a estar el aut√≥mata despu√©s de haber procesado completamente dicha cadena. Esta funci√≥n extendida se llama ***funci√≥n de transici√≥n extendida o funci√≥n de transici√≥n de cadena*** (o sobre palabras).

Mediante esta dado un determinado automata podemos demostrar que una palabra es admitida, es v√°lida para ese lenguaje o no, veremos en el siguiente ejemplo si el siguiente aut√≥mata acepta la palabra *x=110101*.

<span class="centerImg">![[ALF-demostracion-formal.png]]  </span>

- Un AFD rechaza una palabra si ***x <-> ùõø(q, x) ‚àâ F***.
- Un AFD reconoce o acepta una palabra si ***x <-> ùõø(q, x) ‚àà F*** , es decir, Se consumen todos los s√≠mbolos de entrada y al terminar la palabra, se llega a un estado final.

#### Equivalencia de AFDs

Dado dos aut√≥matas A1 y A2, para comprobar si estos aut√≥matas son equivalentes se utiliza el ***teorema de Moore***.

>[!important] Teorema de Moore
> Dos estados q y q¬¥ son ***compatibles*** si ambos son finales o ninguno de los dos lo es. Si uno es final y el otro no, entonces se dice que son ***incompatibles***.

Entonces, dados dos aut√≥matas ***A(Q, Œ£, Œ¥, q0 , F) y A¬¥(Q¬¥, Œ£¬¥, Œ¥¬¥, q0¬¥, F¬¥)***
1. Inicialmente la ra√≠z del √°rbol es (q0 , q0¬¥).
2. Si en el √°rbol hay un par (r, r¬¥), para cada car√°cter en Œ£ se a√±aden como hijos suyos los pares ***(rœÉ ,rœÉ¬¥)*** donde ***rœÉ = Œ¥(r, œÉ), rœÉ¬¥= Œ¥(r¬¥, œÉ)***, si no existen.
3. Si aparece en el √°rbol un par (r, r¬¥) de estados incompatibles, se interrumpe la construcci√≥n del mismo, concluyendo que los aut√≥matas no son equivalentes. En caso contrario se contin√∫an a partir del paso 2.
4. Si no aparecen nuevos pares que no est√©n en el √°rbol, finaliza el proceso, concluyendo que los aut√≥matas son equivalentes.

#### Minimizaci√≥n de AFD

Los algoritmos que simulan o implementan automatas finitos deterministas suelen requerir un espacio m√°s o menos proporcional al n√∫mero de estados del aut√≥mata, por lo que interesa que el n√∫mero de dichos estados sea el menor posible. En un aut√≥mata puede haber dos tipos de estados *innecesarios*, que es posible eliminar o combinar para minimizar el n√∫mero de estados. Por esta raz√≥n, existen dos operaciones de minimizaci√≥n diferentes:

- ***Eliminaci√≥n de estados inaccesibles***: Un estado es inaccesible si no se puede alcanzar desde el estado inicial del AFD siguiendo cualquier combinaci√≥n de transiciones de entrada. Estos estados no son necesarios para el funcionamiento del AFD y pueden ser eliminados sin afectar su comportamiento.
- ***Agrupaci√≥n de estados equivalentes o indistinguibles***: Dos estados son equivalentes si tienen el mismo comportamiento desde la perspectiva de cualquier cadena de entrada. Es decir, si tienen las mismas transiciones de entrada y salida y llegan a estados finales o no finales de manera similar. La agrupaci√≥n de estados equivalentes en un √∫nico estado reduce el n√∫mero total de estados del AFD.

Un aut√≥mata es una ***simplificaci√≥n*** de otro si tiene menos estados, pero ambos aceptan el mismo lenguaje. Esto se sabe mediante conocer que dos estados de ese aut√≥mata son equivalentes, una vez que sabemos eso podemos eliminar uno de ellos y las "flechas" que salen son eliminadas y las que entran se dirigen al estado equivalente.
Existen dos m√©todos de simplificaci√≥n:

1. **Tabla de estados distinguibles**
	- Dados los estados ***p y q***, ambos son ***distinguibles*** si son ***incompatibles***, es decir, sus transiciones no los llevan a los mismos estados.
	- Si ***Œ¥(p0 , œÉ)=p y Œ¥(q0 , œÉ)=q*** donde p y q son distinguibles, entonces p0y q0 son distinguibles.
	- Forma de realizarlo:
		1. Construir una tabla donde las filas y las columnas son los nombres de los estados.
		2. Marcar con una x cuando los estados sean distinguibles.
		3. Los estados equivalentes (no marcados) podr√°n eliminarse.
1. **Clases de equivalencia**
	- Forma de realizarlo:
		1. Inicialmente, se tienen las clases conformadas por los estados finales y los que no lo son.
		2. Luego sea ***q*** un estado de una de las clases. Para cada uno de los otros estados, ***q¬¥***, verificar si ***Œ¥(q, œÉ)*** va a dar la misma clase de equivalencia que ***Œ¥(q¬¥, œÉ)***, para cada car√°cter œÉ. Esto quiere decir que para cada estado que se encuentra dentro de esa clase, todas las transiciones de estos van a llevar a la misma clase como resultado de la transici√≥n
			- Si la respuesta es si, la clase no necesita dividirse.
			- Si la respuesta es no, dividir la clase en dos subclases, la de los estados con transacciones ‚Äúsimilares‚Äù a ***q*** y otra con los estados con transacciones ‚Äúdiferentes‚Äù a ***q***.

>[!note] Mas Ejemplos
>Todos los ejemplos gr√°ficos estan en las notas de las clases o en la filminas

---

# Aut√≥matas Finitos no Deterministas

Se los define como una qu√≠ntupla ***A = (Q, Œ£, Œ¥, q0 , F)***, en donde:

- **Q** es un conjunto finito no vac√≠o de estados.
- **Œ£** es el conjunto finito de s√≠mbolos de entrada. 
- **Œ¥: Q x (Œ£ U {Œµ}) -> P(Q)** es la funci√≥n de transici√≥n.
- **q0** ‚àà Q el estado inicial.
- **F** ‚äÇ Q es el conjunto de estados finales

Al igual que los aut√≥matas finitos deterministas, los no deterministas se pueden representar a trav√©s de grafos o de tablas de estados. A diferencias de los deterministas, los automatas finitos no deterministas poseen una particularidad que es la ***relaci√≥n lambda***.

>[!important] Relaci√≥n Lambda
>Dado dos estados *p* y *q* de un AFN, est√°n relacionados mediante una relaci√≥n lambda si en la transici√≥n a otro estado no se consume ning√∫n car√°cter de entrada, es decir, hace una transici√≥n a otro estado sin la necesidad de recibir una entrada.
>- **Clausura transitiva de la relaci√≥n lambda**: dado un conjunto de estados { *p, q, r* } si ***(p, q)*** poseen una relaci√≥n lambda, y adem√°s ***(q, r)*** a su vez poseen una relaci√≥n lambda, entonces ***(q, r)*** tambi√©n poseen una relaci√≥n lambda.
>- **Clausura transitiva y reflexiva de la relaci√≥n**: Posee todos los elementos de la clausura transitiva de la relaci√≥n, agregando al grupo las transiciones lambda que posee cada estado consigo mismo, es decir, (p y p) o (q y q).

#### Funci√≥n de Transici√≥n sobre Palabras

- Dada una funci√≥n de transici√≥n no determinista, ***Œ¥:QxŒ£ -> P(Q)***. La funci√≥n de transici√≥n sobre palabras, se define as√≠: ***ùõø(ùëû, ùë•)*** como el conjunto de estados al que llega el aut√≥mata, tras procesar x, partiendo del estado *q*.
- Dada una funci√≥n de transici√≥n no determinista: ***Œ¥: Q x (Œ£ U { é}) -> P(Q)***. La funci√≥n de transici√≥n sobre palabras, se define como el conjunto de estados al que llega el aut√≥mata desde un estado concreto, tras procesar una cadena de s√≠mbolos de entrada.

>[!info] Lenguajes Aceptados por un AFN
>Decimos que un AFN reconoce o acepta una palabra si:
>1. Se consumen todos los s√≠mbolos de entrada.
>2. Si al terminar la palabra, se llega al estado final.
>
>El lenguaje aceptado por un AFN, es el conjunto de palabrasaceptadas por √©l.

>[!note] Aspectos de dise√±o del AFNs
>Al retirar algunas restricciones que tienen los AFD, su dise√±o para un lenguaje dado puede volverse m√°s simple, a su vez existe si, una dificultad, que radica en lo dif√≠cil que es llegar a saber qu√© camino tomar.
>Existen dos modelos modulares de dise√±o de ***aut√≥matas finitos no deterministas***:
>- **AFN para la uni√≥n de Lenguajes**: Dado dos lenguajes L1 y L2, para lograr concatenar estos dos lenguajes √∫nicamente se tiene que agregar un estado m√°s que tenga una transici√≥n hacia los estados iniciales de cada aut√≥mata mediante una relaci√≥n lambda.
>
><span class="centerImg"> ![[ALF-union-lenguajes.png]] </span>
>
>- **AFN para la concatenaci√≥n de Lenguajes**: Dado dos lenguajes L1 y L2, para lograr una concatenaci√≥n de lenguajes lo que se debe hacer es de los estado finales de un aut√≥mata, se crean transiciones vac√≠as (relaci√≥n lambda) entre los estados finales del primer aut√≥mata hacia el estado inicial del segundo aut√≥mata. Convirtiendose cada uno de los estado finales del primer aut√≥mata en estados no finales.
>
><span class="centerImg"> ![[ALF-concatenacion-lenguajes.png]] </span>

#### Equivalencia AFN y AFD

Informalmente, un AFN es una extensi√≥n de un AFD que permiten ciertas transiciones prohibidas para √©stos:
- A partir de un estado concreto, no es preciso que el aut√≥mata tenga prevista alguna transici√≥n a otro estado (o al mismo) en respuesta a todos los s√≠mbolos de entrada posibles.
- A partir de un estado concreto, y ante un s√≠mbolo de entrada, se permite que el aut√≥mata transite a m√°s de un estado distinto.
- No es obligatorio consumir un s√≠mbolo de entrada para que el aut√≥mata cambie estado.

Para todo AFN N, existe un AFD D tal que L(N) = L(D).
- Se puede construir un AFD equivalente a un AFN dado. Utilizando el m√©todo que se basa en considerar el ***conjunto de estados*** en los que podr√≠a encontrarse el AFN al haber consumido una cierta entrada.

<span class="centerImg"> ![[ALF-equivalencia1.png]] </span>

Se hace algo parecido al teorema de Moore para demostrar que dos automatas son equivalentes. Con la diferencia que en este caso se van construyendo nuevos grupos de estados y se para una vez que no se forme ning√∫n grupo nuevo. 
Los estados van a ser finales, y en el conjunto de estados hay al menos un estado final.

- Se puede construir un AFN equivalente a un AFD dado. Utilizando las transiciones Œµ.

<span class="centerImg"> ![[ALF-equivalencia2.png]] </span>

Se dise√±a un AFD para cada palabra que se quiera aceptar. Se combinan todos los AFD en un AFN que reconozca el lenguaje completo, donde los antiguos estados iniciales dejan de serlo, se crea un nuevo estado inicial, se a√±aden transiciones ***Œµ*** desde el nuevo estado inicial a los antiguos estados iniciales.