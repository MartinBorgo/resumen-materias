
Cuando se pasa a la etapa de implementación del lenguaje, el implementador es el que se encarga de decidir sobre el tiempo de ligadura de las variables, al igual que la forma en la que se va a traducir el código. Aunque esto último está muy influenciado por el tiempo en el que se ligan las variables con los datos que éstas representan, si se elige una liga en tiempo de ejecución se va a optar por un intérprete como forma de traducción; en cambio si se opta por ligar las variables antes de la ejecución el programa se va a traducir utilizando un compilador.

## Interpretes

Es un traductor que ejecuta un programa escrito en un LP de alto nivel, directamente sobre una máquina.

>[!important] Acciones del intérprete
> El intérprete ejecuta repetidamente la secuencia: 
> 1. Obtiene la siguiente sentencia a ejecutar.
> 2. Determina las acciones que han de ser ejecutadas.
> 3. Ejecuta las acciones.
> 
> Cada acción de un programa, se chequea y ejecuta en el momento en que se las encuentra, por esta misma razon los lenguajes interpretados son mas lentos que los compilados. Se puede decir que funcionana de la misma forma que el ciclo ***fetch*** del procesador. 

<span class="centerImg"> ![[LP-interpretes.png]] </span>

## Compiladores

Es un traductor que toma nuestro programa fuente y produce un programa equivalente en una forma adecuada para su ejecución sobre una máquina.
Este proceso de compilación es realizado por varios programas, primero el ***compilador*** toma el programa fuente, una vez compilado se obtiene un *programa objeto*, a continuación un ***enlazador o linkeador*** agrega código objeto de otros programas o librerías a nuestro programa objeto, como resultado obtenemos un *programa ejecutable*, el cual podrá ser cargado en memoria mediante un ***cargador***.

>[!info] Cargadores
> Cuando nosotros obtenemos el ejecutable del programa todos los archivos estan enlazados mediante direcciones relativas, cuando el ***cargador*** carga el programa dichas direcciones pasan a ser direcciones absolutas.

El proceso de compilación consiste en dos pasos:
1. Análisis del programa fuente de entrada
2. Síntesis del programa objeto ejecutable

<span class="centerImg"> ![[LP-compilador.png]] </span>

- **Análisis léxico**: en esta primer etapa suceden unas cuantas cosas ->
	- **Analiza elementos léxicos y los agrupa**: agarra un lote de caracteres, los agrupa formando sentencias y los analiza para ver si:
		1. Dichos caracteres pertenecen al alfabeto propio del lenguaje
		2. Las palabras formen parte de nuestro lenguaje
	- **Identificación del tipo de cada componente léxico**: junta los componentes léxicos (palabras) y las asigna al grupo al que pertenezcan (token).
	- **Representación interna**: guarda todas estos componentes léxicos en la tabla de símbolos, a la cual, en posteriores procesos se le agregara más información a cada componente.
- **Análisis sintáctico**: agrupa los componentes léxicos formando estructuras, las evalúa para comprobar sí dichas expresiones  son válidas para ese lenguaje y las va convinando para formar diferentes frases gramaticales. Una vez finalizada esta etapa queda conformado el árbol de análisis sintáctico.
- **Análisis semántico**: En esta etapa el código fuente comienza a tomar forma, en esta etapa se analizan las estructuras sintácticas y se comprueba que dichas estructuras cuenten con el significado correcto de acuerdo a su contexto, por lo general se cuenta con un analizador específico para cada tipo de estructura (laxema).

>[!info] Cosas que suceden en el Análisis Semántico
>- **Inserción de información implícita**: al código que nosotros escribimos se le aplican las convenciones predeterminadas en caso de que el lenguajes las posea, por ejemplo en Fortran se puede declarar una variable y luego usarla sin necesidad de declarar su tipo, pero si la variable comenzaba con letras que iban de la ***I a la N*** es tomada como entero, de lo contrario es tomada como real, el compilador agregaba los datos necesarios que no se registre ningun error.
>- Tanto el ***analizador sintáctico como semántico*** deben poder detectar los errores cuando se presentan y generar un mensaje apropiado. Al mismo tiempo que deben determinar la mejor manera de continuar con el análisis semántico del resto del programa.
>- Se procesan los macros y operaciones en tiempo real.
>	- Un macro es una porción de codigo que esta por fuera de nuestro programa y que va a ser insertado en el programa, la caracteristica principal de los macros es que para que estos puedan ser llamados deben estar compilados previamente o ser compilado en el momento. A su vez las macros se pueden insertar de dos maneras:
>		1. Se inserta el código fuente de estas macros a nuestro programa fuente y luego se compila.
>		2. Se inserta la macro ya compilada en el programa y al final se termina de compilar.

>[!important] Manteniemiento de la tabra de símbolos
> A lo largo de toda la primera etapa se va construyendo y completando esta tabla, dicha tabla va a asignar un lugar para cada laxema (identificador) diferente encontrado en el programa fuente, que en las sucesivas etapas se les van asignando datos adicionales para cada identificador.
> - En el analisis léxico se introducen los primeros elementos a las tablas.
> - En el analisis semántico se completa la tabla agregando los atributos a cada elemento y se obtiene la información para procesar las estructuras.
> - Las demas etapas utilizaran la información de la tabla para generar código ejecutable eficiente
> 
> Una vez que el proceso de compilación termina la tabla de valores se descarta ya que los tipos, el alcance, el modificador entre otras cosas ya fue evaluado en los procesos anteriores.

- **Optimización**: El analizador semántico produce como salida el programa ejecutable traducido, representado en algún ***código intermedio***, muchas veces esta traducción puede producir código extremadamenta deficiente, es por eso que entra en acción el ***optimizador*** que se encarga de re organizar el código de tal forma que al traducirlo a assembler o a binario este genere un programa lo más optimo y eficiente posible.
- **Generación de código**: Después de la optimización, se transforman los enunciados a lenguaje Assembler, código de máquina u otra forma de programa objeto que va a constituir la salida de la traducción (.obj). Este proceso implica dar el formato apropiado a la salida, basándose en la información que contiene la representación interna del programa.
- **Vinculación**: por ultimo se toman todos estos subprogramas ya previamente traducidos, se indexan unos con otros y se genera un archivo ejecutable.

|            | Ventajas                                                                                                          | Desventajas                                                                                                                             |
|------------|-------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------|
| Interprete | Permite la implementación fácil de muchas operaciones de depuración. Los errores se marcan en la línea de origen. | Ejecución más lenta que un sistema compilado. Requiere más espacio. La tabla de símbolos debe estar presente durante la interpretación. |
| Compilador | Ejecución rápida. La decodificación se realiza una sola vez.                                                      | El traductor es relativamente grande y complejo.                                                                                        |

## Hibridos

Con el paso de tiempo surgio la idea de convinar ambos metodos, con el fin de convinar lo mejor de ambos mundos; en éste tipo de lenguajes el traductor traslada un programa escrito en un lenguaje de programación de alto nivel a un ***lenguaje intermedio***, para que luego el programa sea ejecutado por un interprete.
Esto nos brinda mas seguridad a la hora de escribir los programas, al mismo tiempo que hace al lenguaje mas flexible, siendo a su vez mas rapido que un lenguaje interpretado puro. El mejor ejemplo de esto es Perl, Java o C#.
El proceso usado en una implementación híbrida es similar al siguiente:

<span class="centerImg"> ![[LP-hibridos.png]] </span>

---

## Administración de Memoria en Ejecución

<span class="centerImg"> ![[LP-implementacion-memeoria.png]] </span>

>[!important] Diferencia entre Registro de Activación e Instancia de Registro de Activación
>Un registro de activación es una estructura estática que contiene tipos de datos, que va variando dependiendo el lenguaje donde se haya implementado. Mientras que una instancia de registro de activación es dinámica, se crea a partir del registro de activación cuando se llama/activa un subprograma y es guardado en una pila (es eliminada cuando se finaliza/desactiva el subprograma, regresando a la instancia anterior).

<span class="centerImg"> ![[LP-implementacion-memoria2.png]] </span>

>[!note] Uso de los Heaps en el Tiempo de Ejecición
>En tiempo de ejecición los heaps son muy utiles para guardar las instancias de objetos y estructuras de datos que se usan en la ejecución
