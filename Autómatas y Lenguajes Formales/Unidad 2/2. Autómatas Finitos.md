
Los estados son el único medio que disponen los AF para recordar los eventos que ocurren. Estos automatas se pueden dividir en:

1. Autómatas Finitos Deterministas (AFD).
2. Autómatas Finitos No Deterministas (AFN).

Estos automatas pueden ser representados mediante el ***modelo de sistemas discretos***, con este modelo se trata de representar la realidad continua de forma sencilla, para que estos modelos cumplan correctamente su función deben tenerse en cuenta que modelo o situación se está representando y si lo hace correctamente.
En los modelos de sistemas discretos, los estados y las transiciones deben estar bien distinguidos. 

>[!note] Nota
>Para este tipo de autómatas los estados son excluyentes, lo que significa que solo se puede tener un estado u otro, no ambos al mismo tiempo.

## Autómatas Finitos Deterministas

Características

>[!important] El determinismo en los Autómatas Finitos
>Un autómata finito puede ser determinista si, para cada estado y cada símbolo de entrada, existe una transición única a otro estado. Es decir, dado un estado y un símbolo de entrada, el autómata determinista siempre sabe exactamente a qué estado debe moverse a continuación, sin necesidad de tomar decisiones o elegir entre varias opciones.
>Esta característica de un ***autómata finito determinista*** lo hace más fácil de implementar y analizar, ya que su comportamiento está completamente determinado por su estructura y función de transición.

- Solo se puede estar en un único estado luego de leer una entrada.
- Para cada entrada solo existe uno y solo un estado al que el autómata puede hacer la transición a partir del estado actual (determinismo).
- Presentan estados “saturados”, que sea saturado, significa que para cada estado, debe existir una transición para cada símbolo del alfabeto que procesa.

>[!info] Dato
>Este tipo de autómatas son reconocedores de lenguajes.

A su vez, estos automatas pueden ser representados como una quíntupla ***A = (Q, Σ, δ, q0, F)*** en donde:

- ***Q*** es un conjunto finito no vacío de estados.
- ***Σ*** es el conjunto finito de símbolos de entrada.
- ***δ: Q x Σ -> Q*** es la función de transición.
- ***q0 ∈ Q*** es el estado inicial.
- ***F ⊆ Q*** es el conjunto de estados finales.

#### Representación de AFD

Estos se pueden representar de dos maneras, mediante un diagrama de transiciones (grafo) o una tabla de transiciones (matriz), cualquiera de los dos son prácticas, a continuación un ejemplo de ambas representaciones:

<span class="centerImg"> ![[ALF-AFD.png]] </span>

Con el fin de mostrar un ejemplo más amplio que muestre todos los componentes de este tipo de autómatas, le ponemos una imagen más representativa.

<span class="centerImg"> ![[ALF-AFD2.png]] </span>

#### Diseño de AFD

A la hora de diseñar un AFD que sirva para la aceptación de un lenguaje, se presentan dos posibles problemas:

1. **Solución Incorrecta** -> Que sobren palabras en las sentencias
2. **Solución Incompleta** -> Que falten palabras en las sentencias

Por eso, para diseñar uno de la manera más correcta se debe deben crear estados intermedios que "recuerden" condiciones importantes en el problema que se busca solucionar. A su vez, proponer transiciones que permitan pasar de un estado a otro.
Para facilitar esta parte existen dos métodos de diseño

1. **Por Conjuntos de Estados** -> En este método asociamos condiciones a grupos de estados, con lo que logramos aumentar el grado de abstracción. Por Ej.:

<span class="centerImg"> ![[ALF-diseño-conjunto-estados.png]] </span>

>Como podemos ver, primero se crean grupos abstractos que representan una situación particular y luego se intenta representar esos grupos mediante estados y transiciones que favorezcan esa representación.

2. **Por Complemento** -> Al igual que el modelo anterior, se asocia las condiciones que una determinada cadena a grupos, con la particularidad que luego los estados que representan la situación son invertidos. Véase el ejemplo:

<span class="centerImg"> ![[ALF-diseño-complemento.png]] </span>

## Reconocimiento de Palabras

Como ya hemos nombrado anteriormente, estos autómatas en particular son reconocedores de lenguajes, ellos reciben una cadena de caracteres y determinan si pertenece o no al lenguaje, todo eso siguiendo los siguientes pasos

1. El AFD comienza en el estado inicial con el primer símbolo de la palabra y transita al siguiente estado.
2. A partir del estado en que quedó, transita a un nuevo estado al recibir como entrada el símbolo siguiente.
3. Después de procesar el último símbolo de la cadena de entrada, el AFD ha alcanzado cierto estado. Si dicho estado es final, la palabra se considera aceptada. En caso contrario, se considera rechazada.

#### Extensión de la Función de Transición

A partir de la función de transición de un AFD compuesta de la siguiente manera -> ***𝛿(𝑞, 𝑎)/𝑎 ∈ ∑***. Se puede definir otra función denominada función de transición extendida, la cual se puede definir formalmente de forma recursiva:

<span class="centerImg"> ![[ALF-definicion-recursiva.png]] </span>

>[!important] Sobre la Función de Transición Extendida
>La extensión de la función de transición se refiere a la posibilidad de extender esta función de transición a cadenas de símbolos del alfabeto de entrada, de tal forma que se pueda obtener el estado final en el que debería estar el autómata después de haber procesado completamente dicha cadena. Esta función extendida se llama ***función de transición extendida o función de transición de cadena*** (o sobre palabras).

Mediante esta dado un determinado automata podemos demostrar que una palabra es admitida, es válida para ese lenguaje o no, veremos en el siguiente ejemplo si el siguiente autómata acepta la palabra *x=110101*.

<span class="centerImg">![[ALF-demostracion-formal.png]]  </span>

- Un AFD rechaza una palabra si ***x <-> 𝛿(q, x) ∉ F***.
- Un AFD reconoce o acepta una palabra si ***x <-> 𝛿(q, x) ∈ F*** , es decir, Se consumen todos los símbolos de entrada y al terminar la palabra, se llega a un estado final.

#### Equivalencia de AFDs

Dado dos autómatas A1 y A2, para comprobar si estos autómatas son equivalentes se utiliza el ***teorema de Moore***.

>[!important] Teorema de Moore
> Dos estados q y q´ son ***compatibles*** si ambos son finales o ninguno de los dos lo es. Si uno es final y el otro no, entonces se dice que son ***incompatibles***.

Entonces, dados dos autómatas ***A(Q, Σ, δ, q0 , F) y A´(Q´, Σ´, δ´, q0´, F´)***
1. Inicialmente la raíz del árbol es (q0 , q0´).
2. Si en el árbol hay un par (r, r´), para cada carácter en Σ se añaden como hijos suyos los pares ***(rσ ,rσ´)*** donde ***rσ = δ(r, σ), rσ´= δ(r´, σ)***, si no existen.
3. Si aparece en el árbol un par (r, r´) de estados incompatibles, se interrumpe la construcción del mismo, concluyendo que los autómatas no son equivalentes. En caso contrario se continúan a partir del paso 2.
4. Si no aparecen nuevos pares que no estén en el árbol, finaliza el proceso, concluyendo que los autómatas son equivalentes.

#### Minimización de AFD

Los algoritmos que simulan o implementan automatas finitos deterministas suelen requerir un espacio más o menos proporcional al número de estados del autómata, por lo que interesa que el número de dichos estados sea el menor posible. En un autómata puede haber dos tipos de estados *innecesarios*, que es posible eliminar o combinar para minimizar el número de estados. Por esta razón, existen dos operaciones de minimización diferentes:

- ***Eliminación de estados inaccesibles***: Un estado es inaccesible si no se puede alcanzar desde el estado inicial del AFD siguiendo cualquier combinación de transiciones de entrada. Estos estados no son necesarios para el funcionamiento del AFD y pueden ser eliminados sin afectar su comportamiento.
- **Agrupación de estados equivalentes o indistinguibles**: Dos estados son equivalentes si tienen el mismo comportamiento desde la perspectiva de cualquier cadena de entrada. Es decir, si tienen las mismas transiciones de entrada y salida y llegan a estados finales o no finales de manera similar. La agrupación de estados equivalentes en un único estado reduce el número total de estados del AFD.

Un autómata es una ***simplificación*** de otro si tiene menos estados, pero ambos aceptan el mismo lenguaje. Esto se sabe mediante conocer que dos estados de ese autómata son equivalentes, una vez que sabemos eso podemos eliminar uno de ellos y las "flechas" que salen son eliminadas y las que entran se dirigen al estado equivalente.
Existen dos métodos de simplificación:

1. **Tabla de estados distinguibles**
	- Dados los estados ***p y q***, ambos son ***distinguibles*** si son ***incompatibles***, es decir, sus transiciones no los llevan a los mismos estados.
	- Si ***δ(p0 , σ)=p y δ(q0 , σ)=q*** donde p y q son distinguibles, entonces p0y q0 son distinguibles.
	- Forma de realizarlo:
		1. Construir una tabla donde las filas y las columnas son los nombres de los estados.
		2. Marcar con una x cuando los estados sean distinguibles.
		3. Los estados equivalentes (no marcados) podrán eliminarse.
1. **Clases de equivalencia**
	- Forma de realizarlo:
		1. Inicialmente, se tienen las clases conformadas por los estados finales y los que no lo son.
		2. Luego sea ***q*** un estado de una de las clases. Para cada uno de los otros estados, ***q´***, verificar si ***δ(q, σ)*** va a dar la misma clase de equivalencia que ***δ(q´, σ)***, para cada carácter σ. Esto quiere decir que para cada estado que se encuentra dentro de esa clase, todas las transiciones de estos van a llevar a la misma clase como resultado de la transición
			- Si la respuesta es si, la clase no necesita dividirse.
			- Si la respuesta es no, dividir la clase en dos subclases, la de los estados con transacciones “similares” a ***q*** y otra con los estados con transacciones “diferentes” a ***q***.

>[!note] Mas Ejemplos
>Todos los ejemplos gráficos estan en las notas de las clases o en la filminas
