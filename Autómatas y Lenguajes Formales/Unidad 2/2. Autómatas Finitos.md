
Los estados son el Ãºnico medio que disponen los AF para recordar los eventos que ocurren. Estos automatas se pueden dividir en:

1. AutÃ³matas Finitos Deterministas (AFD).
2. AutÃ³matas Finitos No Deterministas (AFN).

Estos automatas pueden ser representados mediante el ***modelo de sistemas discretos***, con este modelo se trata de representar la realidad continua de forma sencilla, para que estos modelos cumplan correctamente su funciÃ³n deben tenerse en cuenta que modelo o situaciÃ³n se estÃ¡ representando y si lo hace correctamente.
En los modelos de sistemas discretos, los estados y las transiciones deben estar bien distinguidos. 

>[!note] Nota
>Para este tipo de autÃ³matas los estados son excluyentes, lo que significa que solo se puede tener un estado u otro, no ambos al mismo tiempo.

## AutÃ³matas Finitos Deterministas

CaracterÃ­sticas

>[!important] El determinismo en los AutÃ³matas Finitos
>Un autÃ³mata finito puede ser determinista si, para cada estado y cada sÃ­mbolo de entrada, existe una transiciÃ³n Ãºnica a otro estado. Es decir, dado un estado y un sÃ­mbolo de entrada, el autÃ³mata determinista siempre sabe exactamente a quÃ© estado debe moverse a continuaciÃ³n, sin necesidad de tomar decisiones o elegir entre varias opciones.
>Esta caracterÃ­stica de un ***autÃ³mata finito determinista*** lo hace mÃ¡s fÃ¡cil de implementar y analizar, ya que su comportamiento estÃ¡ completamente determinado por su estructura y funciÃ³n de transiciÃ³n.

- Solo se puede estar en un Ãºnico estado luego de leer una entrada.
- Para cada entrada solo existe uno y solo un estado al que el autÃ³mata puede hacer la transiciÃ³n a partir del estado actual (determinismo).
- Presentan estados â€œsaturadosâ€, que sea saturado, significa que para cada estado, debe existir una transiciÃ³n para cada sÃ­mbolo del alfabeto que procesa.

>[!info] Dato
>Este tipo de autÃ³matas son reconocedores de lenguajes.

A su vez, estos automatas pueden ser representados como una quÃ­ntupla ***A = (Q, Î£, Î´, q0, F)*** en donde:

- ***Q*** es un conjunto finito no vacÃ­o de estados.
- ***Î£*** es el conjunto finito de sÃ­mbolos de entrada.
- ***Î´: Q x Î£ -> Q*** es la funciÃ³n de transiciÃ³n.
- ***q0 âˆˆ Q*** es el estado inicial.
- ***F âŠ† Q*** es el conjunto de estados finales.

#### RepresentaciÃ³n de AFD

Estos se pueden representar de dos maneras, mediante un diagrama de transiciones (grafo) o una tabla de transiciones (matriz), cualquiera de los dos son prÃ¡cticas, a continuaciÃ³n un ejemplo de ambas representaciones:

<span class="centerImg"> ![[ALF-AFD.png]] </span>

Con el fin de mostrar un ejemplo mÃ¡s amplio que muestre todos los componentes de este tipo de autÃ³matas, le ponemos una imagen mÃ¡s representativa.

<span class="centerImg"> ![[ALF-AFD2.png]] </span>

#### DiseÃ±o de AFD

A la hora de diseÃ±ar un AFD que sirva para la aceptaciÃ³n de un lenguaje, se presentan dos posibles problemas:

1. **SoluciÃ³n Incorrecta** -> Que sobren palabras en las sentencias
2. **SoluciÃ³n Incompleta** -> Que falten palabras en las sentencias

Por eso, para diseÃ±ar uno de la manera mÃ¡s correcta se debe deben crear estados intermedios que "recuerden" condiciones importantes en el problema que se busca solucionar. A su vez, proponer transiciones que permitan pasar de un estado a otro.
Para facilitar esta parte existen dos mÃ©todos de diseÃ±o

1. **Por Conjuntos de Estados** -> En este mÃ©todo asociamos condiciones a grupos de estados, con lo que logramos aumentar el grado de abstracciÃ³n. Por Ej.:

<span class="centerImg"> ![[ALF-diseÃ±o-conjunto-estados.png]] </span>

>Como podemos ver, primero se crean grupos abstractos que representan una situaciÃ³n particular y luego se intenta representar esos grupos mediante estados y transiciones que favorezcan esa representaciÃ³n.

2. **Por Complemento** -> Al igual que el modelo anterior, se asocia las condiciones que una determinada cadena a grupos, con la particularidad que luego los estados que representan la situaciÃ³n son invertidos. VÃ©ase el ejemplo:

<span class="centerImg"> ![[ALF-diseÃ±o-complemento.png]] </span>

## Reconocimiento de Palabras

Como ya hemos nombrado anteriormente, estos autÃ³matas en particular son reconocedores de lenguajes, ellos reciben una cadena de caracteres y determinan si pertenece o no al lenguaje, todo eso siguiendo los siguientes pasos

1. El AFD comienza en el estado inicial con el primer sÃ­mbolo de la palabra y transita al siguiente estado.
2. A partir del estado en que quedÃ³, transita a un nuevo estado al recibir como entrada el sÃ­mbolo siguiente.
3. DespuÃ©s de procesar el Ãºltimo sÃ­mbolo de la cadena de entrada, el AFD ha alcanzado cierto estado. Si dicho estado es final, la palabra se considera aceptada. En caso contrario, se considera rechazada.

#### ExtensiÃ³n de la FunciÃ³n de TransiciÃ³n

A partir de la funciÃ³n de transiciÃ³n de un AFD compuesta de la siguiente manera -> ***ğ›¿(ğ‘, ğ‘)/ğ‘ âˆˆ âˆ‘***. Se puede definir otra funciÃ³n denominada funciÃ³n de transiciÃ³n extendida, la cual se puede definir formalmente de forma recursiva:

<span class="centerImg"> ![[ALF-definicion-recursiva.png]] </span>

>[!important] Sobre la FunciÃ³n de TransiciÃ³n Extendida
>La extensiÃ³n de la funciÃ³n de transiciÃ³n se refiere a la posibilidad de extender esta funciÃ³n de transiciÃ³n a cadenas de sÃ­mbolos del alfabeto de entrada, de tal forma que se pueda obtener el estado final en el que deberÃ­a estar el autÃ³mata despuÃ©s de haber procesado completamente dicha cadena. Esta funciÃ³n extendida se llama ***funciÃ³n de transiciÃ³n extendida o funciÃ³n de transiciÃ³n de cadena*** (o sobre palabras).

Mediante esta dado un determinado automata podemos demostrar que una palabra es admitida, es vÃ¡lida para ese lenguaje o no, veremos en el siguiente ejemplo si el siguiente autÃ³mata acepta la palabra *x=110101*.

<span class="centerImg">![[ALF-demostracion-formal.png]]  </span>

- Un AFD rechaza una palabra si ***x <-> ğ›¿(q, x) âˆ‰ F***.
- Un AFD reconoce o acepta una palabra si ***x <-> ğ›¿(q, x) âˆˆ F*** , es decir, Se consumen todos los sÃ­mbolos de entrada y al terminar la palabra, se llega a un estado final.

#### Equivalencia de AFDs

Dado dos autÃ³matas A1 y A2, para comprobar si estos autÃ³matas son equivalentes se utiliza el ***teorema de Moore***.

>[!important] Teorema de Moore
> Dos estados q y qÂ´ son ***compatibles*** si ambos son finales o ninguno de los dos lo es. Si uno es final y el otro no, entonces se dice que son ***incompatibles***.

Entonces, dados dos autÃ³matas ***A(Q, Î£, Î´, q0 , F) y AÂ´(QÂ´, Î£Â´, Î´Â´, q0Â´, FÂ´)***
1. Inicialmente la raÃ­z del Ã¡rbol es (q0 , q0Â´).
2. Si en el Ã¡rbol hay un par (r, rÂ´), para cada carÃ¡cter en Î£ se aÃ±aden como hijos suyos los pares ***(rÏƒ ,rÏƒÂ´)*** donde ***rÏƒ = Î´(r, Ïƒ), rÏƒÂ´= Î´(rÂ´, Ïƒ)***, si no existen.
3. Si aparece en el Ã¡rbol un par (r, rÂ´) de estados incompatibles, se interrumpe la construcciÃ³n del mismo, concluyendo que los autÃ³matas no son equivalentes. En caso contrario se continÃºan a partir del paso 2.
4. Si no aparecen nuevos pares que no estÃ©n en el Ã¡rbol, finaliza el proceso, concluyendo que los autÃ³matas son equivalentes.

#### MinimizaciÃ³n de AFD

Los algoritmos que simulan o implementan automatas finitos deterministas suelen requerir un espacio mÃ¡s o menos proporcional al nÃºmero de estados del autÃ³mata, por lo que interesa que el nÃºmero de dichos estados sea el menor posible. En un autÃ³mata puede haber dos tipos de estados *innecesarios*, que es posible eliminar o combinar para minimizar el nÃºmero de estados. Por esta razÃ³n, existen dos operaciones de minimizaciÃ³n diferentes:

- ***EliminaciÃ³n de estados inaccesibles***: Un estado es inaccesible si no se puede alcanzar desde el estado inicial del AFD siguiendo cualquier combinaciÃ³n de transiciones de entrada. Estos estados no son necesarios para el funcionamiento del AFD y pueden ser eliminados sin afectar su comportamiento.
- **AgrupaciÃ³n de estados equivalentes o indistinguibles**: Dos estados son equivalentes si tienen el mismo comportamiento desde la perspectiva de cualquier cadena de entrada. Es decir, si tienen las mismas transiciones de entrada y salida y llegan a estados finales o no finales de manera similar. La agrupaciÃ³n de estados equivalentes en un Ãºnico estado reduce el nÃºmero total de estados del AFD.

Un autÃ³mata es una ***simplificaciÃ³n*** de otro si tiene menos estados, pero ambos aceptan el mismo lenguaje. Esto se sabe mediante conocer que dos estados de ese autÃ³mata son equivalentes, una vez que sabemos eso podemos eliminar uno de ellos y las "flechas" que salen son eliminadas y las que entran se dirigen al estado equivalente.
Existen dos mÃ©todos de simplificaciÃ³n:

1. **Tabla de estados distinguibles**
	- Dados los estados ***p y q***, ambos son ***distinguibles*** si son ***incompatibles***, es decir, sus transiciones no los llevan a los mismos estados.
	- Si ***Î´(p0 , Ïƒ)=p y Î´(q0 , Ïƒ)=q*** donde p y q son distinguibles, entonces p0y q0 son distinguibles.
	- Forma de realizarlo:
		1. Construir una tabla donde las filas y las columnas son los nombres de los estados.
		2. Marcar con una x cuando los estados sean distinguibles.
		3. Los estados equivalentes (no marcados) podrÃ¡n eliminarse.
1. **Clases de equivalencia**
	- Forma de realizarlo:
		1. Inicialmente, se tienen las clases conformadas por los estados finales y los que no lo son.
		2. Luego sea ***q*** un estado de una de las clases. Para cada uno de los otros estados, ***qÂ´***, verificar si ***Î´(q, Ïƒ)*** va a dar la misma clase de equivalencia que ***Î´(qÂ´, Ïƒ)***, para cada carÃ¡cter Ïƒ. Esto quiere decir que para cada estado que se encuentra dentro de esa clase, todas las transiciones de estos van a llevar a la misma clase como resultado de la transiciÃ³n
			- Si la respuesta es si, la clase no necesita dividirse.
			- Si la respuesta es no, dividir la clase en dos subclases, la de los estados con transacciones â€œsimilaresâ€ a ***q*** y otra con los estados con transacciones â€œdiferentesâ€ a ***q***.

>[!note] Mas Ejemplos
>Todos los ejemplos grÃ¡ficos estan en las notas de las clases o en la filminas
