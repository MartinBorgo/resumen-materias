Las pruebas de desarrollo incluyen todas las actividades de prueba que realiza el equipo que elabora el sistema.

Las pruebas de desarrollo tiene como meta descubrir bugs en el software.

Generalmente están entrelazadas con la depuración: el proceso de localizar problemas con el código y cambiar el programa para corregirlos.

Durante el desarrollo, las pruebas se realizan en tres niveles de granulación:

1. **Pruebas de unidad:** Se pone a prueba unidades de programa o clases de objetos individuales. Las pruebas de unidad deben enfocarse en comprobar la funcionalidad de objetos o métodos. 

2. **Pruebas del componente:** muchas unidades individuales se integran para crear componentes compuestos. La prueba de componentes debe enfocarse en probar interfaces del componente.

3. **Pruebas del sistema:** algunos o todos los componentes en un sistema se integran y el sistema se prueba como un todo. Las pruebas del sistema deben enfocarse en poner a prueba las interacciones de los componentes

### Pruebas de unidad

Las **pruebas de unidad** son el proceso de probar componentes del programa, como métodos o clases de objetos. 
Las funciones o los métodos individuales son el tipo más simple de componente. 

Cuando se pone a prueba las clases de objetos, se tiene que diseñar las pruebas para brindar cobertura a todas las características del objeto.

Esto significa que debe: 
- Probar todas las operaciones asociadas con el objeto; 
- Establecer y verificar el valor de todos los atributos relacionados con el objeto; 
- Poner el objeto en todos los estados posibles. Esto quiere decir que tiene que simular todos los eventos que causen un cambio de estado.

![[pruebas_unidad.png]]

La **generalización o herencia** provoca que sea más complicada la prueba de las clases de objetos.

No debe poner únicamente a prueba una operación en la clase donde se definió, ni suponer que funcionará como se esperaba en las subclases que heredan la operación. 

### Automatización de pruebas de unidad 

Siempre que sea posible, se deben automatizar las pruebas de unidad. 
En estas pruebas de unidad automatizadas, podría usarse un marco de automatización de pruebas (como JUnit) para escribir y correr las pruebas de programa. 
Los marcos de pruebas de unidad ofrecen clases de pruebas genéricas que se extienden para crear casos de prueba específicos. 

Un conjunto automatizado de pruebas tiene tres partes:

1. Una parte de **configuración**, en la cual se inicializa el sistema con el caso de prueba, esto es, las entradas y salidas esperadas. 

2. Una parte de **llamada** (call), en la cual se llama al objeto o al método que se va a probar.

3. Una parte de **declaración**, en la cual se compara el resultado de la llamada con el resultado esperado. Si la información se evalúa como verdadera, la prueba tuvo éxito; pero si resulta falsa, entonces fracasó.

### Elección de casos de prueba de unidad

Las pruebas son costosas y consumen tiempo, así que es importante elegir casos efectivos de pruebas de unidad.

La efectividad significa:

1. Los casos de prueba tienen que mostrar que, cuando se usan como se esperaba, el componente que se somete a prueba hace lo que se supone que debe hacer. 

2. Si hay defectos en el componente, éstos deberían revelarse mediante los casos de prueba.

En consecuencia, hay que escribir dos tipos de casos de prueba.

El primero debe reflejar una operación normal de un programa y mostrar que el componente funciona. 
Por ejemplo, si se va a probar un componente que crea e inicia el registro de un nuevo paciente, entonces, el caso de prueba debe mostrar que el registro existe en una base de datos, y que sus campos se configuraron como se especificó.

El otro tipo de caso de prueba tiene que basarse en probar la experiencia de donde surgen problemas comunes.

Debe usar entradas anormales para comprobar que se procesan de manera adecuada sin colapsar el componente.

### Lineamientos para casos de pruebas de unidad

Ejemplos de lineamientos que se pueden utilizar en el diseño de casos de prueba.

- Elegir entradas que fuercen al sistema a generar todos los mensajes de error; 
- Diseñar entradas que produzcan que los buffers de entrada se desborden; 
- Repetir varias veces la misma entrada o serie de entradas; 
- Forzar la generación de salidas inválidas; 
- Forzar resultados de cálculo demasiado largos o demasiado pequeños.

### Pruebas de componentes

Los componentes de software son componentes compuestos constituidos por varios objetos en interacción.

![[pruebas_componentes.png]]

Existen diferentes «tipos de interfaz» entre componentes de programa:

- **Interfaces de parámetro**: Son interfaces en que los datos, o en ocasiones referencias de función, pasan de un componente a otro. Los métodos en un objeto tienen una interfaz de parámetro. 

- **Interfaces de memoria compartida**: Son interfaces en que un bloque de memoria se reparte entre componentes. Los datos se colocan en la memoria de un subsistema y otros subsistemas los recuperan de ahí. Este tipo de interfaz se usa con frecuencia en sistemas embebidos, donde los sensores crean datos que se recuperan y son procesados por otros componentes del sistema. 

- **Interfaces de procedimiento**: Son interfaces en que un componente encapsula un conjunto de procedimientos que pueden ser llamados por otros componentes. Los objetos y otros componentes reutilizables tienen esta forma de interfaz.

- **Interfaces que pasan mensajes**: Se trata de interfaces donde, al enviar un mensaje, un componente solicita un servicio de otro componente. El mensaje de retorno incluye los resultados para ejecutar el servicio. Algunos sistemas orientados a objetos tienen esta forma de interfaz, así como los sistemas cliente-servidor.

Existen distintos tipos de error de interfaz que llegan a ocurrir:

**Uso incorrecto de interfaz**: Un componente que llama a otro componente y comete algún error en el uso de su interfaz. 
Este tipo de error es común con interfaces de parámetro, donde los parámetros pueden ser del tipo equivocado, o bien, pasar en el orden o el número equivocados de parámetros.

**Mala interpretación de interfaz**: Un componente que malinterpreta la especificación de la interfaz del componente llamado y hace suposiciones sobre su comportamiento.
Por ejemplo, un método de búsqueda binaria puede llamarse con un parámetro que es un arreglo desordenado. Entonces fallaría la búsqueda.

**Errores de temporización**: Ocurren en sistemas de tiempo real que usan una memoria compartida o una interfaz que pasa mensajes.
El productor de datos y el consumidor de datos operan a diferentes niveles de rapidez. A menos que se tenga cuidado particular en el diseño de interfaz, el consumidor puede acceder a información obsoleta, porque el productor de la información no actualizó la información de la interfaz compartida.

Algunos lineamientos generales para las pruebas de interfaz son:

- Examinar el código que se va a probar y listar explícitamente cada llamado a un componente externo. Diseñar un conjunto de pruebas donde los valores de los parámetros hacia los componentes externos estén en los extremos finales de sus rangos. Dichos valores extremos tienen más probabilidad de revelar inconsistencias de interfaz.

- Donde los punteros pasen a través de una interfaz, probar siempre la interfaz con parámetros de puntero nulo.

- Donde un componente se llame a través de una interfaz de procedimiento, diseñar pruebas que deliberadamente hagan que falle el componente.

- Use pruebas de esfuerzo en los sistemas que pasan mensajes. Esto significa que debe diseñar pruebas que generen muchos más mensajes de los que probablemente ocurran en la práctica. Ésta es una forma efectiva de revelar problemas de temporización.

- Donde algunos componentes interactúen a través de memoria compartida, diseñar pruebas que varíen el orden en que se activan estos componentes. Tales pruebas pueden revelar suposiciones implícitas hechas por el programador, sobre el orden en que se producen y consumen los datos compartidos.

### Pruebas del sistema

Las **pruebas de sistema** demuestran que los componentes son compatibles, que interactúan correctamente y que transfieren los datos correctos en el momento adecuado a través de sus interfaces.

Se traslapan con las **pruebas de componentes**, pero existen dos importantes diferencias:

- Durante las pruebas de sistema, los componentes reutilizables desarrollados por separado y los sistemas comerciales pueden integrarse con componentes desarrollados recientemente. Entonces se prueba el sistema completo.

- Los componentes desarrollados por diferentes miembros del equipo o de grupos pueden integrarse en esta etapa. La prueba de sistema es un proceso colectivo más que individual.

En algunas compañías, las pruebas del sistema implican un equipo de prueba independiente, sin la inclusión de diseñadores ni de programadores.
También se prueban **componentes o sistemas reutilizables** para acreditar que al integrarse nuevos componentes funcionen como se esperaba.

### Desarrollo dirigido por pruebas

![[desarrollo_pruebas.png]]

El código se desarrolla incrementalmente, junto con una prueba para ese incremento.
No se avanza hacia el siguiente incremento sino hasta que el código diseñado pasa la prueba.

![[desarrollo_pruebas2.png]]

Además de la mejor comprensión del problema, otros beneficios del desarrollo dirigido por pruebas son:

- **Cobertura de código**: Cualquier segmento de código que escriba debe tener al menos una prueba asociada. El código se prueba a medida que se escribe, de modo que los defectos se descubren con oportunidad en el proceso de desarrollo.

- **Pruebas de regresión**: Un conjunto de pruebas se desarrolla incrementalmente conforme se desarrolla un programa.

- **Depuración simplificada**: Cuando falla una prueba, debe ser evidente dónde yace el problema. Es preciso comprobar y modificar el código recién escrito. No se requieren herramientas de depuración para localizar el problema.

- **Documentación del sistema**: Las pruebas en sí actúan como una forma de documentación que describen lo que debe hacer el código.          Leer las pruebas suele facilitar la comprensión del código.

Uno de los beneficios más importantes del desarrollo dirigido por pruebas es que **reduce los costos** de las pruebas de regresión.

El desarrollo dirigido por pruebas se usa más en el diseño de software nuevo, donde la funcionalidad se implementa en código nuevo o usa librerías estándar perfectamente probadas.

Si se reutilizan grandes componentes en código o sistemas heredados, entonces se necesita escribir pruebas para dichos sistemas como un todo.

Si se usa el desarrollo dirigido por pruebas, se necesitará de un proceso de **prueba del sistema** para validar el sistema; esto es, comprobar que cumple con los requerimientos de todos los participantes del sistema.

**El desarrollo dirigido por pruebas resulta ser un enfoque exitoso para proyectos de dimensión pequeña y mediana.**