Cuando se realiza una consulta a una base de datos, cada solicitud especifica la dirección en disco donde se encuentran los registros, generalmente identificada por el número de bloque del disco. Estos bloques luego se transfieren del disco a la memoria principal.
Las bases de datos se almacenan en archivos en disco, y estos archivos se dividen en bloques, cada uno de los cuales puede contener varios elementos de datos y viceversa. Dado que los datos están en la memoria secundaria, el acceso es mucho más lento que si estuvieran en la memoria principal. Por ello, uno de los objetivos de un sistema de gestión de bases de datos es minimizar las transferencias de bloques entre el disco y la memoria, manteniendo en esta última la mayor cantidad posible de bloques. Esto aumenta la probabilidad de que, al necesitar acceder a un bloque, ya se encuentre en la memoria principal, evitando así el costoso acceso al disco. Sin embargo, como no es posible mantener todos los bloques en la memoria principal, es necesario gestionar eficazmente la asignación del espacio disponible.

## Memoria Intermedia

La memoria intermedia es un gran _buffer_ ubicado en la memoria principal que almacena copias de los bloques del disco. Aunque siempre se guarda una copia en el disco, esta puede ser una versión más antigua que la que está en la memoria.
Los sistemas de gestión de bases de datos cuentan con un subsistema dedicado a la administración de esta memoria intermedia, conocido como _**gestor de memoria intermedia (GMI)**_. Cuando los gestores de bases de datos necesitan un bloque del disco, realizan una solicitud al GMI. Este verifica si el bloque solicitado ya está en el buffer y, de ser así, proporciona la dirección del bloque en la memoria principal. Si el bloque no está en el buffer, el GMI asigna espacio en la memoria para cargarlo.
Puede ocurrir que el buffer esté lleno, en ese caso el GMI debe liberar espacio descartando algunos bloques. Si los bloques descartados han sido modificados, sus cambios deben guardarse en el disco antes de ser eliminados. Las estrategias para decidir qué bloques descartar son variadas, pero una de las más comunes es _**Least Recently Used (LRU)**_, que elimina del buffer el bloque al que se ha hecho menos referencia recientemente. Esta estrategia es la empleada por los sistemas operativos.
Normalmente el GMI de las bases de datos suelen marcar ciertos bloques como ***bloques clavados***, esto quiere decir que dicho bloque no puede ser eliminado del buffer, por lo general entran en esta categoría los bloques que son accedidos más frecuentemente o de forma concurrente, mejorando así los tiempos de respuesta y evitando posibles errores.

>[!tldr] Salida Forzada de Bloques
>Hay situaciones en la que resulta necesario volver a escribir el bloque en el disco, por más que el buffer tenga espacio suficiente para alojar nuevos bloques. Este proceso de ***salida forzosa*** se lleva a cabo para asegurar la persistencia de los datos y proteger al sistema de posibles caídas.
>Los sistemas operativos no están pensados para trabajar con bloques clavados ni salidas forzosas por lo que estas prestaciones resultan esenciales a la hora de implementar un sistema de gestión de bases de datos.

Anteriormente, mencionamos que los sistemas operativos utilizan el mecanismo de ***LRU*** para predecir futuras referencias a los bloques en memoria principal. En contraste, los sistemas de gestión de bases de datos suelen emplear el esquema ***Most Recently Used (MRU)*** para el reemplazo de bloques, ya que las bases de datos manejan los datos de manera diferente a los sistemas operativos. Esta técnica permite predecir con mayor precisión las futuras referencias, anticipando qué bloques serán necesarios al analizar las etapas involucradas en la operación solicitada por el usuario.

## Organización de los Archivos

Las bases de datos se componen de distintos archivos, a su vez los archivos se organizan lógicamente como secuencias de registros. Estos registros se corresponden con los bloques del disco, los cuales son de un tamaño fijo y generalmente son establecidos por el sistema operativo, en cambio, los tamaños de los registros pueden ser fijos o variables.
En caso de que los registros sean fijos surgen una serie de problemas, supongamos que el tamaño de nuestros registros es de 40 bytes y tenemos un archivo compuesto por una gran cantidad de estos registros, en este caso surgen dos problemas:

1. Resulta difícil borrar registros de esta estructura.
2. Puede que algunos registros se saltarán los límites de los bloques.

El primer problema surge cuando, al eliminar un registro, es necesario rellenar el espacio vacío, lo que implica desplazar físicamente todos los registros posteriores al eliminado, resultando en una operación muy costosa. Una alternativa es mover el último registro del archivo al lugar del registro eliminado, lo cual es más eficiente, aunque requiere acceso adicional al disco, lo que tampoco es ideal. Una opción más eficiente es dejar el espacio del registro eliminado vacío y reutilizar esos espacios en futuras inserciones. En este caso, el archivo tendría una cabecera con un puntero al primer registro vacío, que a su vez apuntaría al siguiente espacio libre, y así sucesivamente.

![[registros-fijos.png]]

>[!tldr] Borrado de los Registros
>Generalmente el borrado de los registros es lógico, ya que las operaciones de borrado en disco son costosas, lo que ralentizaría al motor de bases de datos, por esta razón se opta por marcar dichos registros como borrados y reescribirlo en posteriores inserciones. 

Por otro lado, en los archivos con registros de longitud variable, el registro insertado puede no ajustarse al espacio liberado del registro eliminado o solo ocupar parte de ese espacio. La necesidad de manejar registros de longitud variable surge por varias razones en los sistemas de gestión de bases de datos. Por ejemplo, algunas bases de datos almacenan distintos tipos de registros en un mismo archivo, otras permiten que uno o más campos tengan longitudes variables, e incluso existen bases de datos que admiten registros con campos repetidos. Existen diversas formas de implementar registros de longitud variables:

- **Representación en cadena de bytes**: Es una forma simple de implementar los registros variables, consiste de una agrupar bytes de forma consecutiva e indicar con un delimitador el final del registro. Este modelo de implementación tiene la desventaja que no resulta sencillo volver a utilizar el espacio ocupado anteriormente por un registro borrado y por lo general no queda espacio para el aumento del tamaño de los registros.
- **Estructura de Páginas con Ranuras**: Consiste en un bloque que posee una cabecera al principio el cual contiene la siguiente información:
	1. El número de elementos del registro de la cabecera.
	2. El final del espacio vacío del bloque.
	3. Un arreglo que contiene la ubicación y el tamaño de cada registro en el bloque.

>[!tldr] Borrado de un Registro
>Cuando se borra un registro se libera el espacio, marcando como borrado a dicho registro, posteriormente se desplazan los registros de bloque situados antes del registro borrado. Todo el espacio libre vuelve a hallarse entre la cabecera y el primer registro. También se actualiza de manera adecuada el puntero de final del espacio libre de la cabecera. Se puede aumentar y/o disminuir el tamaño de los registros utilizando técnicas parecidas siempre que quede espacio en el bloque.

- **Representación de longitud fija**: Hay dos técnicas para implementar este tipo de registros variables:
	- **Espacio reservado**: Los registros tienen una longitud máxima que no se supera nunca, pudiendo utilizar registros de longitud fija dentro de esa longitud. El espacio no utilizado por los registros más cortos que el espacio máximo se rellena con un símbolo especial de valor nulo o de final de registro.
	- **Representación con listas:** El registro de longitud variable se representa mediante una lista de registros de longitud fija, enlazada mediante punteros.

### Organización de los Registros en Archivos

Los archivos manejados por una base de datos puede categorizarse de acuerdo a la forma en la que estos organizan sus registros.

- **Montículo**: Se puede colocar cualquier registro en cualquier parte del archivo en el que haya espacio suficiente.
- **Secuenciales**: Se guardan en orden secuencial, basado en el valor de la clave de búsqueda de cada registro.
- **Agrupaciones**: Se guardan en el mismo archivo registros pertenecientes a relaciones diferentes.
- **Asociativa**: Se calcula una función de asociación (hash) de algún atributo de cada registro. El resultado de la función de asociación especifica el bloque del archivo en que se deberá colocar el registro.

Los archivos secuenciales están diseñados para procesar registros de manera eficiente según un orden definido por una ***clave de búsqueda***. Para recuperar registros rápidamente, cada uno incluye un puntero que señala al siguiente en el orden establecido por dicha clave. Para reducir el número de accesos a los bloques durante el procesamiento, los registros se almacenan físicamente siguiendo el orden de la clave de búsqueda. 
El borrado se puede gestionar mediante cadenas de punteros, conocidas como ***lista de libres***, y para las inserciones se siguen estas reglas:

1. Localizar el registro que precede al que se va a insertar según el orden de la clave de búsqueda.
2. Si hay un espacio vacío en la lista de libres dentro del mismo bloque que dicho registro, el nuevo registro se insertará ahí. De lo contrario, se almacenará en un bloque de desbordamiento. En cualquier caso, los punteros deben ajustarse para mantener el orden según la clave de búsqueda.

>[!important] Características de los Archivos Secuenciales
>- Permite la inserción rápida de nuevos registros.
>- Funciona bien para un número relativamente pequeño de registros en los bloques de desbordamiento.
>- Periodicametne se debe reorganizar el archivo de modo que vuelva a estar físicamente en orden secuencial.

Algunos sistemas de gestión de bases de datos relacionales almacenan cada relación en un archivo separado para aprovechar al máximo el sistema de archivos del sistema operativo. Generalmente, las tuplas de cada relación se representan como registros de longitud fija, lo que es adecuado para sistemas diseñados para computadoras personales, donde es crucial mantener un tamaño reducido del código del gestor de base de datos. En cambio, otras bases de datos no confían la gestión de archivos al sistema operativo. En su lugar, asignan un archivo de gran tamaño al motor de base de datos, donde se almacenan todas las relaciones, dejando la gestión de dicho archivo al gestor de la base de datos.

>[!tldr] Agrupaciones de Archivos
>Las agrupaciones de archivos son una forma de organización que almacena registros de dos o más relaciones en un mismo bloque. Aunque este enfoque mejora el rendimiento en operaciones de *joins*, puede aumentar el tiempo de procesamiento en otros tipos de consultas, como aquellas que acceden a los registros de una única relación. En estos casos, se requieren más accesos a los bloques en comparación con otros esquemas, ya que, en lugar de encontrar varios registros de una misma relación en un bloque, cada uno puede estar en bloques diferentes.
>De hecho, encontrar todos los registros de una tabla específica en un esquema de agrupación no es posible sin una estructura adicional. Por ejemplo, para localizar todos los registros de una tabla determinada, sería necesario vincular todos los registros de este tipo mediante punteros.
