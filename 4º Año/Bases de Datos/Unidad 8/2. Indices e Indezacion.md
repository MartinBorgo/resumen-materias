Muchas consultas hacen referencia sólo a una pequeña parte de los registros de un archivo, por lo que lo más adecuado sería que el sistema fuese capaz de localizar directamente estos registros. Además, hay casos en que se necesita un orden de acceso. Para facilitar estas formas de acceso se diseñan estructuras adicionales que se asocian a los archivos conocidas como ***índices***.
Hay básicamente dos tipos de índices:

- **Índices ordenados** que están basados en una disposición ordenada de los valores.
- **Índices asociativos** los cuales están basados en una distribución uniforme de los valores a través de una serie de cajones (buckets). El valor asignado a cada cajón está determinado por una función de asociación (hash).

Existen varias técnicas de ***indexación y asociación*** de indices. Cada una de estas técnica tienen su propia área de aplicación que resuelve problemas específicos que se presentan al utilizar bases de datos. Cada técnica debe ser valorada según los siguientes criterios:

- Tipos de acceso.
- Tiempo de acceso.
- Tiempo de inserción.
- Tiempo de borrado.
- Espacio adicional requerido.

Los atributos o conjunto de atributos usados para buscar en un archivo se llaman ***claves de búsqueda*** ($K_B$), cada estructura de índice está asociada con una cable de búsqueda concreta. Si el archivo que contiene los registros está ordenado secuencialmente, el índice cuya clave de búsqueda especifica el orden secuencial del archivo es el índice primario.
Los índices primarios también se llaman ***índices con agrupación*** mientras que los índices cuyas clave de búsqueda especifican un orden diferente del orden secuencial del archivo se llaman índices secundarios o ***índices sin agrupación***.

## Índices Primarios

Por lo general se suele asumir que todos los archivos están ordenados secuencialmente según alguna clave de búsqueda, este tipo de archivos reciben el nombre de ***archivos secuenciales indexados***. y suelen ser empleados en aquellas aplicaciones que demandan un procesamiento secuencial del archivo completo así como un acceso directo a sus registros.

![[indice-secuencial.png]]

### Índices Densos y Dispersos

Un ***registro índice o entrada del índice*** consiste en del valor de la clave de búsqueda y punteros a uno o más registros con ese valor de la clave de búsqueda. Por su parte el puntero a un registro consiste en el identificador de un bloque de disco y un desplazamiento en el bloque de disco para identificar el registro dentro del bloque, de acuerdo al tipo de punteros utilizados podemos dividir a los indices ordenados en dos clases:

- **Índices densos**: Posee un registro índice por cada valor de clave de búsqueda que exista en el archivo. Los registros índices contiene el valor de la clave de búsqueda y el puntero al primer registro con el valor de esa clave de búsqueda.

![[indices-densos.png]]

- **Índices dispersos**: Solo posee registros índices para algunos de los valores de clave de búsqueda que se encuentran en el archivo, en este tipo de índices para local un registro se busca la entrada con el valor más grande que sea menor o igual que el valor que se está buscando.

![[indice-disperso.png]]

>[!tldr] ¿Que Índice es más Conveniente?
>Generalmente es más rápido localizar un registro si se usa un índice denso en vez de un índice disperso. Sin embargo, los índices dispersos utilizan menos espacio y un mantenimiento adicional menor para las inserciones y borrados.
>Los diseñadores del sistema debe buscar un balance entre el tiempo de acceso, el espacio adicional requerido y tiempo de actualización. Si bien la decisión sobre que tipo de índices se deben utilizar depende de la aplicación en particular, un buena decisión es tener un índice disperso con una entrada del índice por cada bloque, de esta forma se minimizan los accesos a bloques mientras mantenemos el tamaño del índice tan pequeño como sea posible.

## Índices Multinivel

Aunque se utilicen índices dispersos, el propio índice podría ser demasiado grande para un procesamiento eficiente, si un índice es lo bastante pequeño como para guardarlo en la memoria principal, el tiempo de búsqueda para encontrar una entrada sería mucho menor. Mientras que si el índice es tan grande que se debe guardar en disco. Estos se almacenan como archivos secuenciales en disco, esto significa que buscar una entrada implicará leer varios bloques de disco, por ejemplo, para un índice de 100 bloques, una búsqueda binaria necesitará leer siete bloques. Esto empeora si se están utilizando bloques de desbordamiento, en este caso la búsqueda binaria no sería posible y eso requiere leer los 100 bloques.
Para resolver este problema se trata el índice como un archivo secuencial y se construye un índice disperso sobre el índice primario. En caso de que se quiera localizar un registro se usa en primer lugar una búsqueda binaria sobre el índice más externo para buscar el registro con el mayor valor de la clave de búsqueda que sea menor o igual al valor deseado. El puntero de ese registro índice apunta a un bloque en el índice más interno, sobre el cual se realizará el mismo proceso de búsqueda, dando como resultado un registro índice cuyo puntero apunta al bloque del archivo que contiene el registro buscado.

![[indices-multinivel.png]]

Usando los dos niveles de indexación y con el índice más externo en memoria principal, tenemos que leer un único bloque índice en vez de los siete que se leían con la búsqueda binaria. Si al archivo es extremadamente grande, incluso el índice exterior podría crecer demasiado para caber en la memoria principal. En este caso se podría crear todavía otro nivel más de indexación. Este proceso de división se podría repetir tantas veces como fuese necesario.

## Actualización de Índices

Sin importar el tipo de índice que se esté usando, los índices se deben actualizar siempre que se inserte o borre un registro del archivo, este tipo de operaciones van a realizarse o no dependiendo de si el índice es denso o disperso, por ejemplo, en el caso de los índices dispersos, no todas las operaciones de inserción/borrados afectan a los índices.
Los índices secundarios son aquellos cuyas clave de búsqueda especifican un orden diferente del orden secuencial del archivo, por lo tanto estos deben ser densos, con una entrada en el índice por cada valor de la calve de búsqueda, y un puntero a cada registro del archivo.
Un índice secundario sobre una clave candidata es como un índice denso primario, con la particularidad de que los registros apuntados por los sucesivos valores del índice no están almacenados secuencialmente. Si la clave de búsqueda de un índice secundario no es una clave candidata, no sería suficiente apuntar sólo al primer registro de cada valor de la clave de búsqueda, ya que el resto de registros con el mismo valor de la clave de búsqueda podrían estar en cualquier otro sitio del archivo, para solucionar este problema se puede usar una estructura multinivel para implementar los índices secundarios sobre claves de búsquedas que no sean claves candidatas.

>[!tldr] Consideraciones para los Índices Secundarios
>Siguiendo el orden de un índice primario, una búsqueda secuencial es eficiente porque los registros del archivo están guardados físicamente en el mismo orden que el índice. No se puede almacenar el archivo ordenado físicamente por el orden de la clave de búsqueda del índice primario y la clave de búsqueda del índice secundario al mismo tiempo, ya que el orden de la clave de búsqueda secundaria y el orden físico difieren. Si se intenta examinar el archivo secuencialmente por el orden de la clave de búsqueda secundaria, es muy probable que la lectura de cada bloque suponga la lectura de un nuevo bloque del disco.
>Si un archivo tiene varios índices, siempre que se modifique el archivo, se debe actualizar cada uno de ellos. Los índices secundarios mejoran el rendimiento de las consultas que emplean claves que no son la de búsqueda del índice primario, pero requieren de tiempo adicional al modificar la base de datos.

## Índices de Árbol B⁺

El principal problema de los índices mencionados anteriormente es el rendimiento, ya que tanto la búsqueda en el índice como el recorrido secuencial de los datos se ven afectados negativamente a medida que aumentan los tamaños de los archivos. En este contexto, la estructura de índice de árbol $B^+$ es la más utilizada entre las estructuras de índices porque mantiene su eficiencia incluso con la inserción y eliminación de datos.
Un índice de árbol $B^+$ toma la forma de un árbol balanceado donde los caminos de la raíz a cada hoja del árbol son de la misma longitud. Cada nodo que no es una hoja tiene entre $p/2$ y $p$ hijos, donde $p$ es fijo para cada árbol en particular.
Si bien utilizar esta estructura de datos implica una reducir el rendimiento al insertar y al borrar, además de ocupar espacio adicional, este tiempo adicional es aceptable incluso en archivos con altas frecuencias de modificación, ya que se evita el costo de reorganizar el archivo. En pocas palabras un ***índice de árbol $B^+$*** es un índice multinivel en el cual todos sus nodos internos tienen la siguiente forma:

$$
< P_1 , K_1, P_2 , K_2, \cdots, K_{q–1} , P_q>
$$

Donde $q \leq p$, siendo $p$ el orden del árbol y $K_i$ las claves de búsqueda, mientras que $P_i$ son los punteros de árbol. Esta estructura de datos posee las siguientes características:
1. Para todos los elementos de los nodos internos se cumple que $K_1 < K_2 < K_3 \cdots$.
2. Cada nodo interno a excepción del raíz tiene como máximo $p$ punteros de árbol y al menos $p /2$ punteros de árbol.
3. El nodo raíz tiene como mínimo 2 punteros de árbol si es un nodo interno.
4. Un nodo con $q$ punteros ($q \leq p$) tiene $q – 1$ valores de clave de búsqueda.
5. Todo nodo hoja de los árboles $B^+$ de orden $p$ tienen la siguiente forma:

$$
<< K_1, Pr_1, K_2, Pr_2 ,\cdots, K_{q–1} , Pr_{q-1}> P_{sig}>
$$

>[!info] Información Adicional
>En los nodos hojas se cumple que $q \leq p_{hoja}$, donde $Pr_i$ es un puntero a datos y $P_{sig}$ apunta al siguiente nodo hoja del árbol. Cada $Pr_i$ apunta a un registro de datos cuyo valor de su clave de búsqueda es $K_i$ o apunta a un bloque que tiene ese registro.

6. Cada nodo hoja tiene al menos $p_{hoja} / 2$ valores.
7. Todas las hojas están al mismo nivel de profundidad en el árbol.

![[estructura-nodos-hoja.png]]

8. Los punteros de los nodos internos son punteros a árboles mientras que los punteros de los nodos hoja, a excepción de $P_{sig}$, son punteros a datos. Aunque también se puede utilizar un puntero $P_{ant}$.
9. Si la clave de búsqueda no es clave candidata, cada $Pr_i$ debe apuntar a un cajón de punteros a registros que apuntan a registros cuyo valor de campo es $K_i$.

### Consulta en Árboles B⁺

Supongamos que se desean encontrar todos los registros cuyo valor de la clave de búsqueda sea $V$. Primero se examina el nodo raíz para buscar el menor valor de la clave de búsqueda mayor o igual que $V$. Supóngase que este valor de la clave de búsqueda es $K_i$. A continuación se utiliza el puntero $P_i$ para acceder al otro nodo. Si no se encuentra ese valor, entonces $k \geq K_{q–1}$, donde $q$ es el número de punteros del nodo. Es este caso se sigue $P_q$ hasta el siguiente nodo, este proceso se repite hasta que finalmente se alcanza un nodo hoja.
En el nodo hoja, si se encuentra que el valor $K_i = V$, entonces el puntero $Pr_i$ nos ha conducido al registro o cajón deseado. Si no se encuentra el valor $V$ en el nodo hoja, no existe ningún registro con el valor clave $V$.
Para procesar una consulta, se tiene que recorrer un camino en el árbol desde la raíz hasta algún nodo hoja. Si hay $n$ valores de clave de búsqueda en el archivo, este camino no será más largo que $log_{p/2} (n)$. Generalmente un nodo se construye para tener el mismo tamaño que un bloque de disco, el cual ocupa normalmente 4 KiB.

>[!tldr] Eficiencia en la Búsqueda en los Índices de Árboles B⁺
>Supongamos que el tamaño de las claves de búsqueda posee un tamaño de 12 bytes y un tamaño del puntero a disco de 8 bytes, entonces $p$ está alrededor de 200. Incluso con una estimación más conservadora de 32 bytes para el tamaño de las claves de búsqueda, $p$ está en torno a 100. Con $p = 100$, si se tienen un millón de valores de clave de búsqueda en el archivo, una búsqueda necesita solamente $log_{50} (1.000.000) = 4$ accesos a nodos.

### Actualizaciones en Árboles B⁺

El borrado y la inserción son más complicados que las búsquedas, ya que podría ser necesario:

1. Dividir un nodo como resultado de una inserción.
2. Fusionar y/o redistribuir nodos como resultado de una eliminación ($q < p/2$ ).

Además, cuando se divide un nodo o se fusionan un par de ellos, se debe asegurar que el árbol siga estando balanceado.
Para las inserciones se utiliza la misma técnica utilizada para la búsqueda de registros, si el valor de la clave de búsqueda ya aparece en el nodo hoja, se inserta un nuevo registro en el archivo y, si es necesario, un puntero al cajón. Pero si el valor de la clave de búsqueda no aparece, se inserta el valor en el nodo hoja de tal manera que las clave de búsqueda permanezcan ordenadas, para a posteriormente insertar el nuevo registro en el archivo y, si es necesario, creamos un nuevo cajón con el puntero apropiado.
Para la eliminación de un registro, se utiliza la técnica de búsqueda para encontrar el registro deseado y se lo elimina del archivo. Si no hay un cajón asociado con el valor de la clave de búsqueda o si el cajón se queda vacío como resultado del borrado, se borra el valor de la clave de búsqueda del nodo hoja.

>[!tldr] Índices de Árbol B
>Los ***índices de árbol B*** son similares a los índices de árbol B⁺, con una leve diferencia en sus enfoques, ya que los árboles B eliminan el almacenamiento redundante de los valores de la clave de búsqueda.
>Como las claves de búsqueda no están repetidas en el árbol B, es posible almacenar el índice empleando menos nodos del árbol que con el correspondiente índice de árbol B⁺. Sin embargo, como las claves de búsqueda que aparecen en los nodos internos no aparecen en ninguna otra parte del árbol B, se debe incluir un campo adicional para un puntero a datos por cada clave de búsqueda de un nodo interno, estos campos adicionales apuntan a registros del archivo o a los cajones de la clave de búsqueda asociada. En otras palabras, el $p$ de los árboles B va a ser menor a los del los árboles B⁺.