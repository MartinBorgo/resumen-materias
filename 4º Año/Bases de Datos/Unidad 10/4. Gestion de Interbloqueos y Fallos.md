Un sistema está en estado de interbloqueo si existe un conjunto de transacciones tal que toda transacción del conjunto está esperando a otra transacción del conjunto, es decir, las transacciones del mismo conjunto están esperando que otras transacciones del mismo conjunto terminen, causando así una espera circular.
Para tratar de manejar los interbloqueos existen a grandes razgos tres métodos que nos permiten tratar estas situaciones, las cuales son:

- Mecanismos de evación.
- Mecanismos de prevención.
- Mecanismos de detección y recuperación.

## Mecanismos de Evasión

Estos métodos se vasan en utilizar algún protocolo de control de concurrencia, que no admita que el sistema caiga en un interbloqueo, tal como los protocolos de validación, locks grupal o los protocolos basados en grafos. El problema del lock grupal es la inanición, ya que una transacción que necesita muchos datos, nunca logrará bloquear todos los datos necesarios, quedando en estado de espera indefinidamente. Una alternativa a este método es establecer un orden en que se bloquean los datos como lo hacen los protocolos de grafos. Por ejemplo, para evitar interbloqueos entre tablas, se pueden bloquear primero la tabla maestro y luego la de detalle.

## Mecanismos Prevención

Los métodos de prevención aseguran que el sistema nunca llegue a un estado de interbloqueo. Un mecanismo para prevenir interbloqueos es la expropiación y/o el retroceso de transacciones. Para controlar estas situaciones, se asigna un tiempo de entrada a cada transacción mediante una función $ts$. A partir de esto, se pueden emplear dos esquemas:

1. **Esperar-morir**: Esta técnica no utiliza expropiaciones. Cuando una transacción $T_i$ solicita un dato que $T_k$ tiene en ese momento, se permitirá que $T_i$ espere solo si $ts(T_i) < ts(T_k)$; de lo contrario, $T_i$ muere, es decir, retrocede.
2. **Herir-esperar**: Esta técnica se basa en expropiaciones. Cuando una transacción $T_i$ solicita un dato que $T_k$ tiene en ese momento, se permitirá que $T_i$ espere solo si $ts(T_i) > ts(T_k)$; de lo contrario, $T_k$ retrocede, y en este caso, se dice que $T_i$ hiere a $T_k$.

En cualquiera de los casos, si una transacción retrocede conserva el valor asignado por $ts$. Esto evita la inanición, dado que una transacción más vieja nunca
retrocede. El problema principal de estos esquemas, es que muchas veces pueden ocurrir retrocesos innecesarios.

## Mecanismos de Detección y Recuperación

Alternativamente, se puede permitir que la base de datos llegue a un estado de interbloqueo para luego detectarlo y recuperarse. Los mecanismos de detección y recuperación se encargan de realizar esta tarea.
Para poder detectar un interbloqueo se debe invocar cada cierto tiempo un algoritmo que se encargue de realizar este chequeo. Para esto el gestor de la base de datos debe:

1. Mantener información acerca de la asignación actual de los datos a las transacciones, así como también de las solicitudes pendientes.
2. Proporcionar un algoritmo que utilice esta información para determinar si el sistema ha entrado en interbloqueo.
3. Recuperarse del interbloqueo cuando el mecanismo de detección indica que existe.

Este mecanismo de detección suele implementarse a través de la construcción de un grafo dirigido conocido como ***grafo de espera (WFG)***, cuyos vértices son las transacciones y sus enlaces indican que transacción están esperando que termine de realizar su tarea.
El algoritmo recorrerá periódicamente el grafo y detectará un interbloqueo si el grafo de espera posee un ciclo, lo que significa que todas las transacciones que forman parte del grafo también están en interbloqueo.

![[ciclo-grafo-espera.png]]

>[!note] Periodicidad para la Aplicación del Algoritmo
>Si los interbloqueos ocurren con frecuencia, deberá invocarse con frecuencia el algoritmo de detección. Un criterio que se puede utilizar para invocar el algoritmo, es cuando el sistema no avanza o no pueda atender de inmediato una solicitud de asignación.

A la hora de realizar la recuperación, la solución más común es retroceder una de las transacciones involucradas para romper el interbloqueo. El criterio de selección para cualquiera de las víctimas se puede regir por cualquiera de los siguientes métodos o una combinación enter ambos:

1. Tiempo que está la transacción activa.
2. Cantidad de datos que ha utilizado.
3. Cuantos datos más necesita la transacción para finalizar.
4. Cuantas transacciones se verán implicadas en el retroceso.

Cabe aclarar que si la elección de una víctima se basa solamente en el factor costo, es posible que siempre se elija la misma víctima, para amortiguar este problema se puede incluir el número de retrocesos en el factor de costo, o incluir un mecanismo de prioridad.

## Recuperación de Fallos

Los fallos que pueden ocurrir en las bases de datos se pueden clasificar en tres grandes categorías

- **Fallo de transacción**: Hay dos tipos de errores que pueden hacer que una transacción falle:
	- **Error lógico**: La transacción no puede continuar con su ejecución normal a causa de alguna condición interna, como una entrada incorrecta, datos no encontrados, desbordamiento o exceso del límite de recursos.
	- **Error del sistema**: El sistema se encuentra en un estado no deseado (por ejemplo en un interbloqueo) como consecuencia del cual una transacción no puede continuar con su ejecución normal. Sin embargo, la transacción se puede volver a ejecutar más tarde.
- **Caída del sistema**: Un mal funcionamiento del hardware o un error en el software de la base de datos o del sistema operativo causa la pérdida del contenido de la memoria volátil y aborta el procesamiento de una o más transacciones. El contenido de la memoria no volátil permanece intacto y no se corrompe.
- **Fallo de disco**: Un bloque del disco pierde su contenido como resultado de una colisión de la cabeza lectora, o bien un fallo durante una operación de transferencia de datos. Las copias de los datos que se encuentran en otros discos o en archivos de seguridad en medios de almacenamiento secundarios, como cintas, se utilizan para recuperarse del fallo, asumiendo que este fallo es detectable.

Para lograr una recuperación adecuada de los datos, se recomienda realizar copias de seguridad en almacenamientos estables. Esto se puede lograr creando y manteniendo múltiples copias de cada bloque en discos separados, de preferencia en sitios remotos, protegiéndose así contra desastres como incendios o inundaciones. Un fallo durante la transferencia de datos puede dar lugar a copias incoherentes, lo cual puede resultar en una de las siguientes situaciones: 

- Una finalización exitosa.
- Un fallo parcial, es decir, el bloque de destino contiene información incorrecta.
- Un fallo total, en el cual el bloque de destino nunca se actualizó.

Para proteger a las copias de seguridad de los fallos de los medios de almacenamiento se pueden ejecutar las operaciones de salida de la siguiente forma:

1. Escribir la información del bloque en el disco.
2. Si la operación de escritura anterior se realizó correctamente, se escribe el siguiente bloque de forma continua en disco.
3. Se termina el proceso de copiado solo si la operación de escritura del último bloque a copias en disco es exitosa.

En caso de que se produzca una falla en la escritura, se puede recuperar la falla mediante los siguientes pasos:

1. Encontrar los bloques inconsistentes. Se pueden comparar las dos copias de cada bloque desde el disco, aunque esto es altamente costoso. Una mejor alternativa sería guardas las escrituras de disco en curso en memoria principal o virtual y utilizar esa información durante la tarea de recuperación, este método es usado por sistemas RAID por hardware.
2. Si se detecta que una copia de un bloque es inconsistente dicho bloque tiene un error, en tal caso se sobrescribe con la otra copia. Si ambos no tienen errores, pero son diferentes, el sistema sustituye el contenido del primer bloque por el valor del segundo.

Cuando en un sistema de gestión de bases de datos se ejecutan transacciones concurrentemente, pueden haber varias transacciones activas en el momento del último punto de verificación o _checkpoint_. Por ello, en un sistema de procesamiento de transacciones concurrentes, es necesario que el registro de bitácora del punto de verificación tenga la forma $<Checkpoint(L)>$, donde $L$ es el conjunto de transacciones activas en el momento del _checkpoint_.
Cuando el sistema se recupera de una caída, va construyendo dos listas: _**L-redo**_ y _**L-undo**_. El gestor examina la bitácora hacia atrás, registro por registro, hasta encontrar un registro de _checkpoint_ y, a continuación, realiza las siguientes tareas:

1. Por cada registro que se encuentre de la forma $<T_i \ Commits>$, se añade $T_i$ a _**L-redo**_.
2. Por cada registro que se encuentre de la forma $<T_i \ Starts>$, si $T_i$ no está en _**L-redo**_, se agrega $T_i$ en la lista _**L-undo**_.

Cuando se han examinado todos los registros de la bitácora posteriores al _checkpoint_, se examina la lista $L$. Por cada transacción $T_i$ en $L$, si $T_i$ no está en _**L-redo**_, se agrega $T_i$ a la lista _**L-undo**_. Posteriormente, se vuelve a examinar la bitácora, esta vez de adelante hacia atrás, y se ejecuta $undo(T_i)$ para cada $T_i$ en _**L-undo**_. La exploración de la bitácora continúa hacia atrás hasta que se hayan localizado los registros $<T_i \ Starts>$ para todas las $T_i$ en _**L-redo**_. Por último, se examina la bitácora hacia adelante y se realiza $redo(T_i)$ para todas las $T_i$ en _**L-redo**_.

>[!info] Registros de Bitácora para el Proceso de Recuperación
>Cuando se ejecuta una operación $undo(T_i)$, si se deben volver un registro $X$ a un valor antiguo $V$ se crea un nuevo registro asentando ese cambio. Al completar esta operación de reversión total de la transacción se asienta en la bitácora un registro del tipo $<T_i \ Abort>$.
>En caso de ejecutar la operación $redo(T_i)$ no hace falta asentar ningún registro nuevo en la bitácora.

La idea básica de una copia de seguridad es volcar periódicamente el contenido entero de la base de datos en almacenamiento estable. Se utilizará la copia más reciente para que la base de datos recupere un estado consistente cuando ocurra un fallo que conduzca a la pérdida de algunos bloques físicos de la base de datos.
Una vez que se complete esta operación, el sistema utilizará la bitácora para llevar al sistema de base de datos al último estado consistente en el que estuvo antes de producirse el fallo.
Durante el procedimiento de volcado ninguna transacción puede estar activa y tendrá lugar una secuencia de acciones similar a la utilizada en los *checkpoint*:

1. Escribe en el almacenamiento estable todos los registros de la bitácora que residan en ese momento en memoria principal.
2. Escribe en disco todos los bloques que se encuentran en los *buffers*.
3. Copiar el contenido de la base de datos en el almacenamiento estable.
4. Escribe el registro $<Dump>$ de la bitácora en el almacenamiento estable.

>[!tldr] Recuperación a Fallas de Disco 
>Para recuperarse de una falla de disco, se deben realizar los siguientes pasos:
>- Restaurar la base de datos de la copia de seguridad más reciente.
>- Consultar la bitácora y rehacer todas las transacciones que se han realizado después del volcado. Este proceso no requiere la ejecución de ninguna operación deshacer.

El procedimiento de volcado simple presentado, conocido como ***volcado en frío***, posee algunos inconvenientes:

- Debe copiarse en un almacenamiento estable la base de datos entera, lo que conlleva una considerable transferencia de datos.
- Se detiene el procesamiento de transacciones durante el procedimiento de volcado.

Por esta razón se han desarrollado esquemas de ***volcado difuso o en caliente*** que permiten que las transacciones sigan activas mientras se realiza la copia de seguridad.