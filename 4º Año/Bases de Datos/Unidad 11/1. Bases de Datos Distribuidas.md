Los sistemas de ***base de datos distribuidas (BDD)*** buscan la integración de diversos sistemas de gestión de bases de datos, no necesariamente homogéneos, para dar a los usuarios una visión global de la información disponible. El proceso de integración no implica la centralización de la información, sino que la información se mantiene distribuida, en diversas localidades y sistemas de de bases de datos distribuidos los cuales permiten el acceso a ella como si estuviera localizada en un solo lugar.
La distribución de la información permite, entre otras cosas, tener copias de la información para accesos más rápidos y para respaldo en caso de fallas. En este tipo de bases de datos cada entidad que la conforma, ya sean tablas, registros, procedimientos almacenados, etc. puede estar compuesta por muchos fragmentos distribuidos por varios nodos.
Cada entidad puede tener varias copias idénticas, logrando así una mayor disponibilidad de los datos y resistencia a fallos. De este modo la caida de un nodo en particular no afectaria el normal funcionamiento del sistema distribuido. Puede que ciertas unidades esten físicamente particionada en varias piezas disjuntas o inclusive que existan varias replicas particionadas. Por lo tanto se puede distinguir entre entidades lógicas (o global) y las distintas copias que existen del mismo en las distintas localidades.

## Fragmentación

Una relación $r$ está fragmentada, cuando se divide en cierta cantidad de fragmentos $r_1, r_2, \cdots , r_n$. Esto fragmentos deben contener la información suficiente  como para reconstruir la relación $R$ original. En las bases de datos distribuidas se pueden dar dos tipo de fragmentación, la ***fragmentación horizontal*** y la ***fragmentación vertical***.
En la fragmentación horizontal se divide las relaciones asignando cada tupla de $R$ a uno o varios fragmentos, donde cada fragmento tendría la siguiente forma:

$$r_i = \sigma_p(r)$$ 
Para explicar este ejemplo con mayor claridad, supongamos que tenemos una relación que conteiene los datos de las cuentas vancarias de los clientes de cada sucursal, una fragmentación horizontal seria que a cada fragmento se le asigmen solo las tuplas pertenecientes a una sucursal en particular, por ejemplo:

$$r_j = \sigma_{sucursal=Concordia}(Cta\_Cte)$$

En la fragmentación vertical se devide la entidad en varios subconjuntos de atributos sobre el esquema $R$ de dicha relación, donde cada fragmento tiene la siguiente forma:

$$r_i = \varPi_{R_i}(r)$$

En este caso la fragmentación debe realizarce de manera tal que se pueda reconstruir la relación $r$ a partir de los distintos $r_i$. Supongamos que el esquema de nuestra tabla clientes tiene los campos identificador, edad, nombre, apellido y fecha de nacimiento, se podría fragmentar verticalmente esta tabla si creamos dos subconjuntos que solo tengan la columna edad, fecha de nacimiento e identificador, y otro subconjunto separado que tenga el apellido, nombre y el identificador. En este caso el atributo identificador estará en ambos subconjuntos porque es la única manera de poder reensambar la relación original.

## Tolerancia al Fallo

Una aspecto importante en un sistema de bases de datos distribuidos, es la red de comunicación. La topología de la red tiene implicancia directa para la tolerancia a fallos, se puede optar por un esquema de conexión total donde cada nodo de la red esta conectado a cada uno de los demás nodos de la red o se puede implementar un esquema de conexión parcial como sería una topologia de estrella o anillo. La primera de las opciones es la mejor, ya que posee una gran tolerancia a fallos y una alta disponibilidad, con la desventaja de que es muy costosa de implementar, el segundo esquema es más barato en terminos generales pero dependiendo de la topología seleccionada puede tener mas o menos tolerancia a los fallos.

>[!tldr] Localidad
>En las bases de datos distribuidas, cada localidad es conciente de la existencia de las demás, permite la ejecución de transacciones locales como si fueran globales y asume que se esta utilizando el mismo software de control de bases de datos que la bases de datos distribuida.
>Adicionalmente el gestor de la base de datos tiene un diccionario que conteiene información sobre los fragmentos, es decir, los datos que contienen dichos fragmentos y en que localidad reciden estos mismos.

## Commitment Distribuido

En las bases de datos distribuidos se pueden tener ***transacciones locales*** que procesan datos que estan localizados y administrados localmente, y ***transacciones globales*** las cuales acceden a datos localizados en nodos de una o más localidades.
Cuando una transacción accede a datos localizados en distintas localidades, esta es dividida en subtransacciones. De este modo cada transacción global esta compuesta en subtransacciones $\{T_1, T_2, \cdots, T_i\}$ donde cada $T_i$ en un particupantes en la transacción. Además cada transacción global tiene un nodo de disparo, también llamado ***coordinador***.
Una transacción distribuida debe comprometerse en todas las localidades o abortarse totalmente. Cuando se ejecuta una transacción global, primero se debe ejecutar cada una de las subtransacciones de forma local, posteriormente se obtienen los resultados de ejecución de cada una de estas subtransacciones. Si al menos una subtransacción fue abortada entonces se abortas las demás transaccinones, en caso contrario se comprometerá la transacción y se asentarán los cambios.
Para llevar adelante este proceso se utiliza un ***protocolo de concenso***. Este protocolo funciona bien solo en ausencia de fallos, ya que si una transacción $T_i$ responde al coordinador que esta dispuesta a comprometerse esta quedara esperando la respuesta final del coordinador, pudiendo pasar alguno de los siguientes casos:

1. Si no recibe una respuesta por parte del coordinador, la transacción permanece en estado de espera indefinidamente, reteniendo todos los datos que bloqueo, en caso de que utilice un mecanismo de locking.
2. No puede abortarse la transacción, ya que si opto por comprometerse y las demás transacciónes también se comprometieron, debe esperar que el coordinador envie un mensaje de *commit* a todas las transacciones y de este modo hacer permanentes los cambios.
3. No puede comprometer la transacción porque si lo hace y luego el coordinador decide abortar, la transacción habrá hecho permanentes los cambios en los datos, estos pueden ser leidos por otra transacción y producir una lectura en sucio.

### Commitment de Dos Fases

Para solucionar los problemas antes mencionados se incorpora un ***timeout*** o tiempo de espera desde que se envía un mensaje de *vote-commit*. Si transcurre un largo tiempo, pasa a un estado de recuperación enviando un mensaje un *help-me* a las demás participantes, quedando bloqueada la transacción hasta obtener una respuesta. Si un participante no recibe ninguna respuesta, se mantiene bloqueado, probablemente esté cortada la comunicación con los demás participantes.
En el caso del coordinador, si se vence el timeout, es decir, uno o más participantes no votan, puede abortar y envía un mensaje de abort a todos los demás participantes que puedan escucharlo.
Para la recuperación ante fallas, las bitácoras de las bases de datos distribuidas no solo deben guardar las modificaciones de los datos, sino también los mensajes que la subtransacción envia y recibe esto le sirve al sistema para recuperarse ante fallos de red o caidas de un nodo. Cuando un nodo se recupera de una falla o se reconecta luego de un tiempo de no poder acceder a otra parte de la red, tiene que averiguar que sucedió con las transiciones que estaban activas cuando la falla o desconexión ocurrió, dicha información se encuentra en su bitácora.

>[!tldr] Proceso de Recuperación de Commitment de dos Fases
>Si el mensaje de *begin-vote* fue recibido por $T_i$, este es guardado con la lista de participantes que el mismo contiene, así puede saber a quien consultar. Por ejemplo si $T_i$ envió un mensaje comprometiendose y luego se desconecta, el coordinador ya puedo haber tomado la desición, pero $T_i$ nunca escucho. Entonces consulta a uno de los participantes y se da cuenta que pasó. En caso de que haya recibido un *begin-vote* pero no votó todavía, puede abortar, dado que lo más probable es que el timeout del coordinador se haya vencido.
>Este protocolo impide la mayoría de los bloqueos pero no todos, dado que un participante al recibir un commit del coordinador, sabe que todos votaron por commit, pero no sabe si todos los demás participantes saben que votaron por commit.

### Commitment de Tres Fases

Para lograr un correcta funcionamiento y evitar todos los errores, se creo el ***commitment de tres fases***, en le cual se realizan las siguientes actividades:

1. En la primer fase, el coordinador envía una *begin-vote* a los participantes al igual que en de dos fases. La segunda y tercera fase ocurre sólo si el coordinador recibe vote-commit de todos los participantes.
2. En la fase dos el coordinador envía prepare-commit a todos los participantes. Puede que algunos sistemas de gestion de bases de datos implementen o no confirmaciones de recepción.
3. En la fase tres el coordinador envía commits a todos los participantes y los participantes envían el commits.

Al contrario que los demás mecanismos de control, el commitment en tres fases requiere el cumplimiento de una serie de supuestos para asegurar su correcto funcionamiento:

1. Sólo ocurren fallas en nodos, no de red.
2. Si el nodo falla, corta la comunicación, ya que no se pueden enviar mensajes falsos de compromiso en vez de aborto.
3. Si el nodo falla, queda fuera de acción para el proceso de commit, debiendo conocer que fallo, y una vez recuperado darse a conocer a los demás.
4. Si un nodo no tiene fallas debe responder a los mensajes en un tiempo menor al timeout.
5. La red no pierde mensajes, y distribuye los mensajes en el orden que fueron recibidos.

>[!tldr] Fallos por Timeout
>Un participante puede no recibir un *begin-vote* esperado del coordinador. En ese caso aborta. Si otro participante lo recibió, se dará cuenta que está fallado mientras espera por el *prepare-commit*. Si el coordinador está esperando por los votos y se vence el timeout antes de recibir todos los votos, enviará un mensaje de aborto. Si un participante está en el estado *willing-to-commit* y se produce el timeout, este pasa al estado *recover*, los mismo sucede para aquellos participantes que estén en estado de *ready-to-commit* y no recibe el mensaje del coordinador.

Si el coordinador envía un mensaje de *prepare-commit* e inmediatamente un mensaje de *commit* a un participante, repitiendo esta secuencia para el resto de particupantes entonces este esquema sería equivalente a commitment de dos fases y el bloqueo de la transacción podría llegar a llevarse a cabo. Por lo tanto solo se envían los mensajes commit, luego de enviar el prepare-commit a todos los participantes.
Cuando un participante recibe un *prepare-commit* sabe que todos los participantes están *willing-to-commit*, si un participante $T_i$ recibe el mensaje de commit, este sabe que todos los participantes saben que están *ready-to-commit*.
Como se asume que no hay mensajes perdidos y estos se reciben instantáneamente en orden, cuando el participante $T_i$ se compromete, cada participante o recibió un *prepare-commit*, o fallo con anterioridad. Esto quiere decir que es imposible que estén en los estados *willing-to-commit* y *committed* al mismo tiempo. Esto nos plantea dos situaciones posibles:

1.  Un participante (activo o fallado) no puede entrar en un estado committed mientras algún participante activo está en el estado *willing-to-commit*.
2. Un participante (activo o fallado) no puede entrar en un estado *aborted* mientras algún participante (activo o fallado) entró en el estado *committed* o *ready-to-commit*.

Por estas dos situaciones. Cuando uno o más participantes detectan la necesidad de recuperación a causa de algún timeout tiene que averiguar el estado de los participantes vivos. Si están todos en *willing-to-commit* o *aborted*, se sabe que ningún participante fallado está comprometido, por lo tanto, puede abortar con seguridad. Si cualquiera de estos participantes alcanzó un *ready-to-commit*, entonces ninguna transacción fallada puede estar *aborted*, por lo tanto, puede comprometerse con seguridad. En tal caso primero deben llevarse a todos los demás participantes al estado *ready-to-commit* y luego al estado *committed*. Esto es porque durante la recuperación algún participante puede fallar y puede que algunos participantes esten en *willing-to-commit* y otros en *committed*.
