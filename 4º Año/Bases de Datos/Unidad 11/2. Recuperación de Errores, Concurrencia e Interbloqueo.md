Al especificar un valor de punto de compromiso para cada nodo, se asegura de que el servidor más crítico no se bloquee si se produce un fallo durante la fase de preparación o confirmación. Para establecer la ***commit point strength*** de una base de datos basta con agregar una línea adicional en el archivo de configuración durante la inicialización de esta misma. Este valor solo se utilizará para determinar el punto de commit en una transacción distribuida.
Dado que el punto de commit almacena información sobre el estado de la transacción, este debe ser almacenado en un nodo que no se caiga a menudo y siempre esté disponible en caso de que otros nodos necesiten información sobre el estado de la transacción. Por lo que es recomendable establecer el commit point strength de una base de datos en relación con la cantidad de datos críticos compartidos en ella.

## Transacciones en Duda

El compromiso en tres fases asegura que todos los nodos se comprometan o realicen un retroceso en forma conjunta. En caso de que suceda alguno de los siguientes problemas la transacción se convierte en ***dudosa*** (In-Doubt):

1. Un servidor que ejecuta el software de la base de datos se bloquea.
2. Se desconectan de la red dos o más nodos que estaban involucrados en la transacción global.
3. Se produce un error de software no manejado.

En la mayoría de los casos, la base de datos resuelve automáticamente la transacción que está en duda a través de un ***proceso de recuperación***. Aunque el proceso de resolución de dicho problema depende de la fase en la que se encuentre la transacción distribuida.
Si el error ocurre durante la fase de preparación, la secuencia de eventos que ocurre es la siguiente:

1. Un usuario se conecta a un cliente y ejecuta una transacción de forma distribuida.
2. El coordinador global de la transacción pide a todas las bases de datos involucradas que se comprometan o que retrocedan de acuerdo a las órdenes que esté mismo dé.
3. Una de las bases de datos se bloquea antes de emitir su después de preparación al usuario.
4. Se ejecuta el proceso de recuperación y hace que la transacción retroceda en cada base de datos involucrada en la transacción global una vez que el sistema caído es restaurado.

En caso de que el error ocurra en la fase de compromiso, la secuencia de eventos que sucede es la siguiente:

1. Un usuario se conecta a un cliente y ejecuta una transacción de forma distribuida.
2. El coordinador global de la transacción pide a todas las bases de datos involucradas que se comprometan o que retrocedan de acuerdo a las órdenes que esté mismo dé.
3. El terminal elegido como punto de commit recibe el mensaje de preparado por parte de los demás nodos involucrados.
4. El terminal elegido como punto de commit confirma la transacción localmente y luego envía un mensaje de confirmación al resto de nodos para que ellos también comprometan la transacción.
5. Una de las bases de datos involucradas recibe el mensaje, pero no puede responder debido a un fallo.
6. El proceso de recuperación hace que la transacción se comprometa en dicha base de datos una vez que esta se recupere de su fallo.

Puede que existan ocasiones en las que se tenga que resolver una transacción de forma manual, ya sea porque una transacción en duda tiene bloques en los datos críticos o segmentos en *undo* o porque lo que causo el fallo ya sea de sistema, red o software no puede ser solucionado rápidamente. Cuando se resuelve una transacción de forma manual, primero se debe identificar el número de transacción en cuestión, bases de datos como Oracle te permiten consultar ciertas vistas para saber que bases de datos están involucradas en dicha transacción. En caso de que sea necesario se puede forzar un compromiso o un retroceso, aunque esto suele usarse en casos extremos.

## Control de Concurrencia en Sistemas Distribuidos

Al momento de realizar las transacciones en los sistemas distribuidos se da por supuesto que cada sitio participa en la ejecución de un protocolo de compromiso para garantizar la atomicidad global de las transacciones.
Los diferentes protocolos de bloqueo mencionados en la unidad anterior se pueden utilizar en entornos distribuidos. La única modificación que hay que incorporar es el modo en que el gestor de bloqueos trata los datos replicados, a partir de esa modificación se pueden aplicar distintos enfoques:

- **Gestor único de bloqueos**: Implica que un único gestor $S_i$, maneje todas las solicitudes de bloqueo y desbloqueo. Cuando una transacción necesita bloquear un dato, envía la solicitud a $S_i$, este decide si conceder el bloqueo o retrasarlo hasta que sea posible. Las lecturas de datos se pueden realizar desde cualquier sitio con una réplica, pero las escrituras requieren la participación de todos los sitios con réplicas. Este esquema es sencillo de implementar y facilita el manejo de interbloqueos, ya que todas las solicitudes se concentran en un solo sitio. Sin embargo, se pueden producir cuello de botella en $S_i$, además de presentar cierta vulnerabilidad, porque si $S_i$ falla, se pierde el control de concurrencia, lo que requiere detener el procesamiento o aplicar un esquema de recuperación.
- **Gestión distribuida de bloques**: Distribuye la función de gestor de bloqueos entre varios sitios, donde cada sitio maneja localmente las solicitudes de bloqueo y desbloqueo para los datos almacenados en ese sitio. Cuando una transacción desea bloquear un dato no replicado, envía la solicitud al gestor local del sitio correspondiente. Si el dato ya está bloqueado en un modo incompatible, la solicitud se retrasa hasta que pueda concederse. Una vez aprobada, se notifica al sitio de origen. Este esquema disminuye el cuello de botella y mantiene una implementación sencilla. Sin embargo, el manejo de interbloqueos es más complejo porque las solicitudes se gestionan en múltiples sitios, lo que puede generar interbloqueos globales que requieren algoritmos modificados para su detección y resolución.
- **Copia principal**: Se designa una de las réplicas del dato $Q$ como copia principal de dicho dato, esta copia principal reside en un sitio único, denominado ***sitio principal*** de $Q$. Cuando una transacción necesita bloquear $Q$, solicita el bloqueo en su sitio principal, y la solicitud se gestiona de la misma manera que para datos no replicados. Esto simplifica la implementación del control de concurrencia. Sin embargo, si el sitio principal falla, el dato $Q$ se vuelve inaccesible, incluso si otras réplicas están disponibles en otros sitios.

>[!note] Esquemas Adicionales
>Además de los enfoques antes explicados, existen otros mecanismos de control de concurrencia como el protocolo de mayoría, el protocolo sesgado y el protocolo de consenso de quórum. Si bien poseen sus diferencias, todos ellos poseen un problema muy similar y es que debido a su funcionamiento pueden producirse interbloqueos extremadamente complejos que requieren mecanismos de detección mucho más sofisticados.

Todos los enfoques anteriores se centraban en el uso de esquemas de bloqueo para manejar la concurrencia. Sin embargo, en las bases de datos distribuidas también es posible gestionar la concurrencia mediante un enfoque basado en marcas temporales o utilizando réplicas con niveles reducidos de consistencia.

## Resolución de Interbloqueos

Los algoritmos de prevención y detección de interbloqueos de la unidad anterior pueden adaptarse a sistemas distribuidos, aunque requieren modificaciones. El protocolo de árbol puede utilizarse si se define un árbol global de datos, y el enfoque de ordenación por marcas temporales también es aplicable en entornos distribuidos. La prevención de interbloqueos puede causar esperas y retrocesos innecesarios y podría involucrar más sitios de los necesarios en la ejecución de una transacción.
Si se opta por la detección de interbloqueos, el principal desafío en sistemas distribuidos es mantener un ***grafo de espera***. Generalmente, cada sitio guarda un grafo local de espera que refleja las transacciones locales y no locales que solicitan recursos en ese sitio. Si un grafo local tiene un ciclo, se ha producido un interbloqueo. Sin embargo, la ausencia de ciclos en los grafos locales no garantiza que no haya interbloqueos a nivel global, ya que la combinación de grafos locales puede formar un ciclo. En un enfoque centralizado, un sitio coordinador mantiene un grafo global de espera, que combina todos los grafos locales. Si se detecta un ciclo en este grafo global, se selecciona una transacción como víctima para retroceder. Sin embargo, este esquema puede generar retrocesos innecesarios debido a ciclos falsos causados por desincronización en la comunicación entre sitios.
En un enfoque basado en marcas de tiempo, el período de Time-out debe ser lo suficientemente corto para evitar que las transacciones bloqueadas retengan los locks por demasiado tiempo, pero lo suficientemente largo para prevenir retrocesos innecesarios de transacciones que no están en interbloqueo. Este enfoque no requerir tráfico de mensajes adicionales y no abortar transacciones que no están involucradas en interbloqueos, como sucede en el método de ordenación por marcas temporales. Sin embargo, es propenso a abortar todas las transacciones involucradas en un interbloqueo en lugar de solo una, lo que generalmente sería suficiente para resolver el problema.