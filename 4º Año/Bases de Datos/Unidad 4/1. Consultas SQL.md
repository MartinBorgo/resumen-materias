La estructura básica de una expresión SQL consiste en tres cláusulas: SELECT, FROM y WHERE, de la forma:

```sql
SELECT A1, A2, ... , An
	FROM R1, R2, ... ,Rm
	WHERE P
```

Cada $A_i$ representa a un atributo de tabla, cada $R_i$ a una relación y $P$ es un predicado que se aplica a la consulta.

- **SELECT**: Lista los atributos deseados en el resultado de una consulta, corresponde a la ***proyección*** del álgebra relacional.
	- Al contrario que en el álgebra relacional, SQL permite duplicados en las relaciones, esto es así debido a una cuestión de rendimiento y eficiencia, en caso de que deseemos eliminar duplicados debemos especificarlo explícitamente, utilizando la palabra `DISTINCT`.
	- En caso de que se quiera seleccionar todos los atributos de los componentes de las tablas, se puede usar el símbolo \*, en lugar de especificar todos los atributos de forma explícita.
	- Esta cláusula permite realizar operaciones aritméticas básicas entre constantes y valores de atributos.

>[!caution] Sintaxis de las Consultas SQL
>Existe un estándar que especifica todas las operaciones que debe incluir SQL y como es su sintaxis, pero cada implementador de la base de datos toma decisiones de como será la sintaxis de su lenguaje de consulta, por lo que pueden existir una serie de diferencias entre las consultas entre distintas bases de datos, aunque estas son mínimas.

- **WHERE**: Especifica las condiciones que el resultado debe satisfacer, corresponde al predicado de la selección del álgebra relacional.
	- En esta cláusula se utilizan conectores lógicos como `and`, `or` y `not`.
	- Permite usar operadores de comparación como >, <, =, entre otros. SQL permite utilizar estos operadores con distintos tipos de datos como cadenas de textos o incluso fechas.
	- En esta cláusula se puede utilizar el operador especial `between` para especificar intervalos de valores válidos. Este operador incluye ambos valores extremos del intervalo de valores especificados. Un ejemplo del uso de este operador es el siguiente:

```sql
SELECT num_prestamo
	FROM prestamo
	WHERE importe BETWEEN 90000 AND 100000
```

- **FROM**: Lista las relaciones involucradas en la consulta. Define un producto cartesiano de las relaciones listadas.
	- Si en esta cláusula se colocan dos tablas que posean un atributo con el mismo nombre, se debe especificar de qué tabla se quiere seleccionar el atributo, de lo contrario ocurrirá un error, por ejemplo:

```sql
SELECT nombre_cliente, prestatario.numero_prestamo, importe
	FROM prestatario, prestamo
	WHERE prestatario.numero_prestamo = prestamo.numero_prestamo;
```

- **ORDER BY**: Hace que las tuplas resultantes de una consultase presenten en un cierto orden.
	- Se puede incluir la cláusula `desc` para ordenar los elementos de manera descendente y `asc` para ordenarlos de manera ascendente. Ejemplo:

```sql
SELECT DISTINCT C.nombre_cliente
	FROM prestatario C, prestamo P
	WHERE C.num_prestamo = P.num_prestamo AND C.nombre_sucursal = 'NAvacerrada'
	ORDER BY C.nombre_cliente DESC;
```

- **Renombramiento**: SQL proporciona un mecanismo para renombrar tanto relaciones como atributos. Para ello utiliza la cláusula `as`, con el siguiente formato `nombre_viejo as nombre_nuevo`.
- **Variables Tupla**: Las variables tupla se definen en la cláusula FROM al igual que en el cálculo relacional de tuplas y so útiles para realizar ciertos tipos de operaciones, además de permitirnos crear consultas más limpias. Ejemplo:

```sql
SELECT DISTINCT T.nombre_sucursal
	FROM sucursal T, sucursal S
	WHERE T.activo > S.activo AND S.ciudad_sucursal = 'Barcelona'
```

- **Operaciones sobre Cadenas de Texto**: El estándar de SQL define una serie de operaciones y operadores para la manipulación de cadenas, en general son las mismas que se encuentran en cualquier lenguaje de programación, con la diferencia de que dependiendo la base de datos van a variar los operadores y las formas de realizar ciertas operaciones.
- **Operaciones Set**: Son el conjunto de operaciones definidas para los conjuntos, estas son `UNION`, `INTERSECT` y `EXCEPT`, al contrario que con la cláusula ***SELECT***, las operaciones Set si eliminas los duplicados, si se quiere conservar los duplicados se debe especificar explícitamente utilizando la cláusula `ALL`, por ejemplo `UNION ALL`.
	- Considerando que una tupla aparece $m$ veces en $r$ y $n$ veces en $s$, entonces cuando se realice una de estas operaciones que admiten repeticiones, la tupla se repetirá $m + n$ veces en el caso de la unión, $min(m, n)$ veces para la intersección y $max(0, m-n)$ en caso de la diferencia.
- **Funciones de una Fila**: Toman uno o más valores de entrada de una sola fila, y retorna un valor por cada fila. Algunos ejemplos de esto son las funciones `UPPER`, `LOWER` o `ABS` entre muchas otras, estas funciones modifican los valores de las filas de manera independiente.
- **Función de Agregación**: Las funciones de agregación son funciones que toman una colección, es decir, un conjunto o multiconjunto de valores como entrada y producen un único valor como salida. SQL proporciona 5 funciones de agregación primitivas, las cuales son `AVG`, `MIN`, `MAX`, `SUM` y `COUNT`.
	- La cláusula `GROUP BY` te permite agrupar los resultados de las funciones de agregación de acuerdo al atributo especificado. Cuando se utiliza esta cláusula solo podrán utilizarse en la cláusula `SELECT`, aquellos atributos que aparezcan en el `GROUP BY`.
	- La cláusula `HAVING` te permite especificar predicados para la cláusula `GROUP BY`, véase el ejemplo:

```sql
-- Lista a todas las sucursales cuyo saldo sea mayor a 1200 dolares
SELECT nombre_sucursal, avg (saldo)
	FROM cuenta
	GROUP BY nombre_sucursal
	HAVING avg (saldo) > 1200
```

### Valores Nulos

SQL permite el uso de valores ***null*** para indicar la ausencia de información sobre el valor de un atributo. En un predicado se puede usar `IS NULL` para comprobar si un valor es nulo. Cualquier comparación que implique un valor nulo, SQL lo trata como desconocido o unknown, es importante tener esto en cuenta debido a que estos valores puede repercutir en las operaciones que se realicen en las consultas.

>[!tldr] Valores Desconocidos y Operadores Lógicos
>Para cada uno de los operadores lógicos, los calores desconocidos pueden alterar el resultado de acuerdo a la operación realizada:
>- **OR**:
>	- (unknown or true) = true.
>	- (unknown or false) = unknown.
>	- (unknown or unknown) = unknown.
>- AND:
>	- (true and unknown) = unknown.
>	- (false and unknown) = false.
>	- (unknown and unknown) = unknown.
>- NOT:
>	- (not unknown) = unknown.
>
>El predicado de una cláusula `WHERE` se trata como falso, si la evaluación es ***unknown***.

Casi todas las funciones de agregación ignoran los valores nulos a la hora de realizar sus cálculos, a excepción de la función `COUNT`. La única forma que alguna de estas funciones de un valor nulo es que no exista ningún valor para dicho atributo en todas las tuplas de la tabla.

### Subconsultas Anidadas

SQL provee un mecanismo para anidar subconsultas. Una subconsulta es una expresión ***select-from-where*** que se anida dentro de otra consulta. Un uso común de subconsultas es llevar a cabo comprobaciones sobre pertenencia a conjuntos, comparación de conjuntos o comparación de valores con un conjunto. Ahora veremos algunos ejemplos de usos comunes.

```sql
-- Todos los clientes que tengan una cuenta y un pŕestamo en el banco
SELECT DISTINCT nombre_cliente
	FROM prestatario
	WHERE nombre_cliente IN (SELECT nombre_cliente FROM depositante);
```

```sql
-- Todas las sucursales que tengan un activo mayor a al menos una sucursal de
-- Barcelona
SELECT nombre_sucursal
	FROM sucursal
	WHERE activo > SOME(SELECT activo
							FROM sucursal
							WHERE ciudad_sucursal = 'Barcelona');
```

```sql
-- Todas las sucursales que tengan un activo mayor a todas las sucursales de
-- Barcelona
SELECT nombre_sucursal
	FROM sucursal
	WHERE activo > ALL(SELECT activo
							FROM sucursal
							WHERE ciudad_sucursal = ‘Barcelona’)
```

La cláusula `EXISTS` se usa para verificar si el resultado de una subconsulta contiene al menos una fila, es decir, el resultado no es un conjunto vacío. Se utiliza principalmente para condiciones donde necesitas comprobar si un conjunto de datos asociado tiene o no algún resultado.
- `EXISTS` | $r \Leftrightarrow r \neq \varnothing$.
- `NOT EXISTS` | $r \Leftrightarrow r = \varnothing$.

Ejemplo de una consulta con esta cláusula:

```sql
-- Clientes que tengan una cuenta en todas las sucursales de Barcelona
SELECT DISTINCT S.nombre_cliente
	FROM depositante S
	WHERE NOT EXISTS ((SELECT nombre_sucursal
						FROM sucursal
						WHERE ciudad_sucursal = 'Barcelona')
					EXPECT
					  (SELECT R.nombre_sucursal
						FROM depositante T, cuentas R
						WHERE T.numero_cuenta = R.numero_cuenta AND
							  S.nombre_cliente = T.nombre_cliente))
```

>[!note] Explicación de la Lógica de la Consulta
>La primera subconsulta obtiene todas las sucursales que pertenecen a Barcelona, la segunda subconsulta obtiene las sucursales en la que cada usuario tiene una cuenta, con el `EXPECT`, lo que lograremos es obtener un conjunto vacío para todos los usuarios que tengan cuentas en todas las sucursales, con `NOT EXISTS` lo que conseguimos es que se agregue la relación resultante todas aquellas personas para las que se obtiene un conjunto vacío.

#### Relaciones Derivadas

SQL permite el uso de subconsultas en la cláusula `FROM`. En una expresión de este tipo se debe dar un nombre a la relación resultado y se pueden renombrar los atributos. Veamos un ejemplo:

```sql
SELECT nombre_sucursal, res.saldo_medio
	FROM (SELECT nombre_sucursal, avg (saldo) as saldo_medio
		FROM cuenta
		GROUP BY nombre_sucursal) res
	WHERE res.saldo_medio > 1200;
```

En esta formulación no es necesario el uso de la cláusula `HAVING` dado que la relación temporal res se calcula en la cláusula `FROM`, y los atributos de la nueva relación de nombre ***res*** se pueden usar directamente en la cláusula `WHERE`.
### Reunión de Relaciones (JOIN)

Las operaciones de reunión toman como entrada dos relaciones y devuelven como resultado otra relación. Los ***tipos de reunión*** definen cómo se tratan las tuplas de cada relación que no encajan con ninguna tupla de la otra relación y la ***condición de reunión*** indica las tuplas pertenecientes a las dos relaciones que encajan y los atributos que se incluyen en el resultado de la reunión.
Dentro de los tipos de reuniones encontramos a los siguientes tipos:

- **INNER JOIN**.
- **LEFT OUTER JOIN**.
- **RIGHT OUTER JOIN**.
- **FULL OUTER JOIN**.

>[!note] Reunión Natural
>Las reuniones naturales en SQL se consiguen a través de la cláusula `NATURAL` que se pone antes del tipo de reunión, de esta forma la reunión se efectuará de acuerdo al atributo en común entre las dos relaciones.

