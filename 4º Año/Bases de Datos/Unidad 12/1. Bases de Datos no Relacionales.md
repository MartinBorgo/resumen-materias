Las bases de datos relacionales satisfacen las necesidades comerciales actuales. Sin embargo, hay motivos para buscar alternativas:

- Necesidad de manejar nuevos tipos multiestructurados, es decir, datos no tabulares.
- Los datos pueden escalar más allá de las limitaciones de capacidad de los sistemas existentes.
- Encontrar alternativas viables a los costosos software y hardware de bases de datos propietarias.
- Agilidad y/o velocidad de desarrollo.
- Flexibilidad ante cambios.

Existen aplicaciones que crean nuevos tipos de dato, los cuales cambian rápidamente, además de introducir volúmenes masivos de estos datos a las bases de datos, estos factores hicieron que se comenzara a considerar de forma más seria la creación de bases de datos que den soporte a este tipo de datos no tabulares.
Sumado a que en la actualidad las aplicaciones se entregan como servicios que deben estar siempre activos, accesibles desde muchos dispositivos diferentes y escalados globalmente con datos distribuidos cerca de sus usuarios para mejorar la latencia y cumplir con la regulación de soberanía de datos. Esto va de la mano con el hecho de que las organizaciones están recurriendo a arquitecturas de escalabilidad horizontal que utilizan software abierto, que se ejecutan en servidores básicos y plataformas de computación en la nube, en lugar de una gran infraestructura monolítica de servidor y almacenamiento.
Todos estos factores obligan a los desarrolladores, ya sea de grupos pequeños o numerosos, a trabajar de forma ágil, iterando de forma rápida y enviando los cambios en el código de forma periódica.
Los sistemas NoSQL no tabulares ofrecen modelos de datos más flexibles, una mayor escalabilidad y rendimiento. Además, gran parte de estas bases de datos mantienen algunas características claves del modelo relacional, como lo puede ser el lenguaje de consulta expresivo, los Índices secundarios o las propiedades ACID, aunque esto última característica solo es respetada por algunas bases de datos no relacionales.
La primera característica que diferencia a las bases de datos no tabulares de las relacionales son sus modelos de datos. Si bien existen muchas bases de datos no tabulares estas pueden ser clasificadas en las siguientes cuatro categorías:

- **Modelo de documentos**: Este tipo de bases de datos, almacena todos los datos en documentos. En este modelo cada documento es en efecto un objeto el cual contiene uno o más campos, cada campo almacena un tipo de valor particular. Los datos en estos documentos suelen ser guardados en una estructura muy similar a un `JSON`. En este tipo de bases de datos, los datos no se guardan en tablas independientes, sino que se almacenan una relación y sus asociaciones en un mismo documento. Estas características simplifican el acceso a los datos y, en muchos casos, elimina la necesidad de operaciones JOIN y transacciones complejas de múltiples registros.

>[!tldr] Características del Modelo Basado en Documentos
>- Las notaciones de los esquemas es dinámico, es decir, cada documento puede contener diferentes campos. Esta flexibilidad es muy útil a la hora de modelar datos no estructurados y polimórficos.
>- Ciertas bases de datos basadas en documentos proporcionan la expresividad para realizar consultas de forma similar a las de las bases de datos relacionales, contando con índices secundarios que brindan acceso eficiente para casi cualquier patrón de consulta.
>- Este tipo de bases de datos fueron pensadas para aplicaciones de propósito general, resultando útiles para un amplio rango de aplicaciones debido en parte a la flexibilidad en los modelos, la capacidad de consulta y el mapeo natural de documentos a objetos.

- **Modelo orientado a grafos**: Utilizan estructuras de grafos con nodos, enlaces y propiedades para representar datos, modelándolos como una red de relaciones entre elementos específicos. Esta estructura facilita el modelado y la navegación por las relaciones entre entidades en una aplicación.

>[!info] Utilización de las Bases de Datos Orientadas a Grafos
>Aunque no es muy intuitivo y puede requerir tiempo para comprenderlo, resulta útil para ciertos tipos de consultas. Es especialmente adecuada para aplicaciones donde las relaciones transversales son fundamentales, como la navegación por conexiones de redes sociales, topologías de redes o cadenas de suministro.

- **Modelos de clave-valor**: Cada elemento se almacena como un par compuesto por una clave y su valor asociado. No obstante, el valor es opaco para el sistema, esto significa que los datos solo pueden ser accedidos a través de sus respectivas clave. Este enfoque es especialmente útil para representar datos polimórficos y no estructurados, ya que no impone un esquema fijo en los pares clave-valor.
- **Modelos de almacenes orientados a columna**: También conocidas como "*almacenes de familias de columnas*", utilizan un mapa ordenado multidimensional distribuido y disperso para almacenar datos. Cada registro puede tener un número variable de columnas, cada columna puede agruparse en familias para facilitar el acceso o distribuirse en varias familias de columnas. Los datos se recuperan utilizando una clave principal por cada familia de columnas. Estas bases de datos son particularmente útiles para aplicaciones que requieren consultas basadas en un único valor clave.

>[!tldr] Usabilidad del Modelo Clave-Valor y Orientado a Columnas
>Estas bases de datos son ideales para aplicaciones que solo requieren consultar datos mediante un único valor clave. Sus principales ventajas son el rendimiento y la escalabilidad, que pueden optimizarse significativamente debido a la simplicidad de los patrones de acceso a los datos y la opacidad del valor.

El modelo de datos clave-valor y de columna es opaca en el sistema, puesto que los datos solo pueden ser accedidos por su clave, con la diferencia que el modelo orientado a columna proporciona acceso mucho más granular a datos que el modelo de clave-valor, pero menos flexibilidad que el modelo de datos del documento.
El modelo basado en documento tiene la aplicabilidad más amplia de todos los modelos antes mostrados, ya que es el más natural y productivo porque los objetos se mapean en forma directa en la base de datos.

## Modelo de Consulta de Datos

Cada aplicación tiene sus propios requisitos de consulta. Algunas aplicaciones pueden solo necesitar acceder a datos mediante una clave primaria, mientras que otra requieren de cierta capacidad para consultar múltiples registros. También es común que las aplicaciones actualicen registros, incluyendo uno o más campos individuales. Para satisfacer estos requisitos, la base de datos necesita poder consultar datos basándose en índices secundarios. En estos casos, una base de datos de documentos a menudo será la solución más adecuada.

### Consultas de Datos en Bases de Datos Basadas en Documentos

Las bases de datos de documentos, permiten consultar y actualizar cualquier campo dentro de un documento. MongoDB, en particular, ofrece diversas opciones de indexación para optimizar consultas, como índices de texto, geoespaciales, compuestos, entre otros. También permite analizar datos directamente sin replicarlos a otros sistemas, utilizando su Marco de Agregación para análisis y transformaciones complejas. Adicionalmente, MongoDB proporciona herramientas de visualización como MongoDB Charts y conectores para Apache Spark y herramientas de inteligencia de negocios.
Para actualizaciones, ofrece métodos avanzados que permiten manipulaciones complejas en documentos, incluso en elementos anidados, dentro de una sola operación transaccional.

### Consultas de Datos en Bases de Datos Basadas en Grafos

Estos sistemas tienden a proporcionar modelos de consulta ricos donde se pueden interrogar relaciones simples y complejas para hacer inferencias directas e indirectas sobre los datos en el sistema. El análisis de tipo relacional tiende a ser muy eficiente en este tipo de bases de datos, mientras que otros tipos de análisis pueden ser menos óptimos. Como resultado, las bases de datos de grafos rara vez se utilizan para aplicaciones operativas de propósito general, si no que se combinan con bases de datos documentales o relacionales regulares para materializar estructuras de datos y consultas específicas de grafos.

>[!tldr] Bases de Datos Multimodelo
>Para intentar controlar la complejidad que surgiría del uso de una multitud de tecnologías de almacenamiento, la industria se está moviendo hacia el concepto de bases de datos multimodelo. Estos diseños se basan en la premisa de presentar múltiples modelos de datos y tipos de consulta dentro de una única plataforma de datos, satisfaciendo así diversos requisitos de aplicación. Por ejemplo MangoDB ofrece una la agregación `&graphLookup` para el procesamiento de grafos de forma nativa.

### Consultas de Datos en Bases de Datos de Clave-Valor y Basadas en Columnas

Estos sistemas proporcionan la capacidad de recuperar y actualizar datos basándose solo en una clave única o en un rango limitado de claves. Para consultar otros valores, es normal que los usuarios construyan y mantengan sus propios índices, puesto que el soporte limitado para índices secundarios, pero con varias advertencias.
Para realizar una actualización en estos sistemas, pueden ser necesarios realizar múltiples etapas, en primer lugar se debe encontrar el registro, luego actualizarlo y después actualizar el índice. En estos sistemas, la actualización puede implementarse como una reescritura completa de todo el registro en el cliente, independientemente de si ha cambiado un solo atributo o todo el registro.

>[!example] Capacidades de Consultas de las Bases de Datos no Relacionales
>La principal diferencia entre las bases de datos no tabulares radica en la capacidad de consultar datos de manera eficiente. Las bases de datos basadas en documentos ofrecen la funcionalidad de consulta más completa, lo que las hace ideales para una amplia variedad de aplicaciones operativas y de análisis en tiempo real.
>Las bases de datos de clave-valor y basadas en columnas proporcionan un acceso rápido a los datos por clave primaria, pero con una funcionalidad de consulta muy limitada, lo que puede generar costos de desarrollo adicionales y la necesidad de implementar soluciones a nivel de aplicación para patrones de consulta más complejos.

## Consistencia y Modelo de Transaccional

La mayoría de los sistemas no tabulares suelen mantener múltiples copias de los datos para propósitos de disponibilidad y escalabilidad. Estas bases de datos pueden imponer diferentes niveles de consistencia entre estas copias, de acuerdo al nivel de consistencia proporcionado por el sistema, las bases de datos no tabulares pueden ser clasificadas en:

- **Fuertemente consistentes**.
- **Eventualmente consistentes**.

En un sistema fuertemente consistente, las escrituras realizadas por la aplicación son inmediatamente visibles en consultas posteriores. Mientras que en un sistema eventualmente consistente, las escrituras no son inmediatamente visibles, dependiendo de qué réplica de datos que se utilice para responder la consulta.
En los sistemas eventualmente consistentes los datos se suelen sincronizarse después de un periodo de tiempo determinado, volviendo a dejar la base de datos en un estado consistente. Por esta razón, el código de la aplicación tiende a ser algo diferente para los sistemas eventualmente consistentes, ya que se obliga al desarrollador emitir consultas idempotentes que establezcan explícitamente la consistencia en la base de datos. Además, los desarrolladores también necesitan construir lógica adicional en sus aplicaciones para manejar datos potencialmente obsoletos o eliminados.
Las bases de datos no tabulares ofrecen garantías de atomicidad a nivel de registro individual, lo que permite reunir datos relacionados. Esta capacidad de operaciones atómicas de registro único satisface las necesidades de integridad de datos en la mayoría de las aplicaciones. Sin embargo, para cargas de trabajo que requieren transacciones multidocumento, algunas bases de datos como MongoDB han agregado soporte a las propiedades ACID en las transacciones, lo que facilita a los desarrolladores abordar una gama más amplia de casos de uso. Aun así, no todas las bases de datos no relacionales soportan los principios ACID.
Los sistemas pueden ser fuertemente consistentemente o eventualmente consistentes, dependiendo de los requisitos de la aplicación. MongoDB permite ajustar la consistencia a nivel de consulta, permitiendo que las operaciones de lecturas se realicen contra las copias secundarias las cuales pueden no estar completamente sincronizadas.

>[!tldr] Sincronización e Inconvenientes de los Sistemas Eventualmente Consistentes
>En sistemas eventualmente consistentes, hay un período en el que las copias de los datos no están sincronizadas, lo que puede ser aceptable para aplicaciones de solo lectura o que almacenan datos que no cambian con frecuencia, como archivos históricos. También resultan útiles para casos específicos de altas tasas de lecturas donde la base de datos está capturando información interna como por ejemplo las bitácoras, las cuales van a ser leídas a posteriori.
>Las actualizaciones y eliminaciones en este tipo de sistemas pueden implicar complejidades adicionales, como la resolución de conflictos entre escrituras en diferentes nodos, con la ventaja que las inserciones de datos suelen tener un rendimiento generalmente bueno.

La mayoría de los equipos de desarrollo esperan sistemas muy consistentes, y la elección de un modelo de consistencia en particular implica diferentes compensaciones en términos de consistencia y disponibilidad, debido a que a mayor sea el grado de consistencia menor será la disponibilidad de los datos.
Los sistemas eventualmente consistentes pueden ofrecer ventajas en inserciones a costa de lecturas, actualizaciones y eliminaciones más complejas. Si bien gran parte de las bases de datos no relacionales proporcionan atomicidad a nivel de registro único, lo cual suele ser suficiente para muchas aplicaciones, para ciertas aplicaciones en particular puede que esto por sí solo no baste. MongoDB, por ejemplo, proporciona garantías ACID multidocumento, facilitando el abordaje de una amplia gama de casos de uso con una única plataforma de datos.

## Flexibilidad y Patrones en Mongo DB

El diseño adecuado del esquema en bases de datos no relacionales permite almacenar más datos de entidad por documento en comparación con una fila en una base de datos relacional. Este tipo de bases de datos ofrece un esquema flexible que acelera el desarrollo al evitar la necesidad de actualizar las asignaciones de clases ORM o recompilar clases de lenguajes de programación. 
Los cambios en el esquema se pueden realizar sin bloquear la base de datos ni degradar su rendimiento, eliminando dependencias complejas entre equipos y la necesidad de coordinación costosa antes de implementar nuevas versiones de código. Los esquemas se pueden modificar en tiempo de ejecución.
En cuanto a la capacidad de consulta, MongoDB permiten realizar búsquedas con condiciones múltiples, geoespaciales, y consultas avanzadas de texto. También ofrecen soporte nativo para JSON binario, permiten realizar reuniones mediante `$lookup`, y consultas por grafos a través de `$graphLookup`.
Los patrones de uso en MongoDB dependen del tipo de aplicación y la forma en que se accede a los datos. Es fundamental considerar el rendimiento, la escalabilidad y la simplicidad al implementarlos.

1. **Approximation (Aproximación)**: Este patrón es útil cuando se realizan cálculos costosos de manera frecuente y la precisión no es crítica.
	- **Ventajas**: Con este patrón se minimizan las escrituras en la base de datos y se asegura el mantenimiento de números estadísticamente válidos.
	- **Desventajas**: los valores calculados no son exactos y la implementación recae en la aplicación, es decir, es la aplicación la que controla las actualizaciones.
2. **Polymorphic (Polimórfico)**: Ideal para situaciones en la cual hay documentos con más similitudes que diferencias y se necesita que los datos se mantengan en una sola colección.
	- **Ventajas**: Este patrón es fácil de implementar y permite que las consultas se ejecuten sobre una sola relación.
3. **Attribute (Atributo)**: Resulta útil cuando se trabaja con documentos grandes con muchos campos similares, pero existe un subconjunto de datos que comparten una característica en común y se desea ordenarlos o consulta ese subconjunto de datos.
	- **Ventajas**: Con la aplicación de este patrón se minimiza la cantidad índices necesarios a la hora de realizar una consulta, además las consultas son más sencillas y rápidas.
4. **Bucket**: Excelente para aquellas situaciones en las que se necesita gestionar transmisiones de datos, series temporales o aplicaciones de IoT.
	- **Ventajas**: Reduce el número total de documentos de una colección, mejora el rendimiento de los índices y puede llegar a simplificar el acceso a los datos aprovechando la agregación previa. Generalmente, este patrón suele combinarse con otros como el *Computed*.
5. **Computed (Calculado)**: Ideal para aquellas situaciones en la que se emplean patrones de acceso intensivo a datos y se realizan cálculos de forma repetitiva.
	- **Ventajas**: Este patrón reduce la carga de la CPU para los cálculos que se realizan más frecuentemente. Además, las consultas se vuelven más sencillas de escribir y por lo general más rápidas.
	- **Desventajas**: El mayor percance de este patrón es que puede ser difícil identificar la situación adecuada para su utilización, sumado al hecho de que se debe evitar la aplicación innecesaria del mismo.
6. **Document Versioning (Versionado de Documentos)**: Ideado para aquellas situaciones en la que se tiene que mantener versiones anteriores de documentos en MongoDB.
	- **Ventajas**: El patrón es fácil de implementar incluso en sistemas existentes y no genera un impacto real en el rendimiento de las consultas sobre las últimas versiones.
	- **Desventajas**: Duplica el número de escrituras y las consultas deben dirigirse a la colección correcta.
7. **Schema Versioning (Versionado de Esquema)**: Ideal para aplicaciones que experimentan cambios en el esquema de datos a lo largo de su vida útil y se requiere que las versiones actuales del documento coexistan con las versiones antiguas del mismo.
	- **Ventajas**: El patrón no requiere tiempo de inactividad, facilita la migración de esquemas y reduce la posibles deuda técnica futura
	- **Desventajas**: La principal desventaja de este patrón radica en que es posible que se requieran dos índices sobre el mismo campos durante la migración.

>[!note] Consideraciones del Patrón Scheme Versioning
>Al implementar este patrón en un sistema existente, se suele agregar un nuevo campo para especificar la versión del esquema, de este modo la aplicación sabrá como manera dicho documento en particular.

8. **Extended Reference (Referencia Extendida)**: Resulta útil para aquellas aplicaciones que utilizan realizan muchas operaciones `JOIN` para reunir datos frecuentemente accesibles.
	- **Ventajas**: Mejora el rendimiento y reduce el número de reuniones a realizar, además de acelerar las operaciones de lectura.
	- **Desventajas**: Se duplican muchos datos, la cual requiere adicionalmente chequeos para asegurarse que el dato esté actualizado.
9. **Outlier (Valores Atípicos)**: Solución para documentos o consultas que no encajan en los patrones de datos típicos utilizados por la aplicación.
	- **Ventajas**: El patrón evita que unos pocos documentos determinen la solución de una aplicación. Las consultas son adaptadas a casos de uso típico, pero aun contemplando los valores atípicos.
	- **Desventajas**: La principal desventaja de este patrón es que se suelen adaptar bien a consultas específicas, pero no tan bien a consultas ad-hoc, además la implementación se realiza mediante código de aplicación lo cual no es muy recomendado.
10. **Pre-allocation (Asignación Previa)**: Adecuado para aquellos casos donde se conoce la estructura del documento y la aplicación solo tiene que llenarlo con datos.
	- **Ventajas**: El patrón simplifica el diseño cuando se conoce de antemano la estructura del documento.
	- **Desventajas**: El patrón intercambia el rendimiento del sistema por la simplicidad del modelo de datos.
11. **Subset (Subconjunto)**: Pensado para aquellas situaciones en donde el conjunto de trabajo excede la capacidad de la RAM debido a documentos grandes donde la gran parte de los datos de este mismo no está siendo utilizado por la aplicación.
	- **Ventajas**: El patrón reduce el tamaño total del conjunto de trabajo y el tiempo de acceso al disco para aquellos datos utilizados más frecuentemente.
	- **Desventajas**: La principal desventaja es que se debe realizar una gestión de los subconjuntos y obtener datos adicionales requerirá de accesos adicionales a la base de datos.
12. **Tree (Árbol)**: Ideada para aquellos casos donde los datos posean una estructura jerárquica y se realizan consultan de forma frecuente.
	- **Ventajas**: El patrón mejora el rendimiento evitando múltiples operaciones `JOIN`.
	- **Desventajas**: Las actualizaciones deben se gestionardas por la aplicación.