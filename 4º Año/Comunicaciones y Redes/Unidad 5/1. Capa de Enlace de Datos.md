La capa de enlace de datos utiliza los servicios de la capa física para enviar y recibir bits a través de los canales de comunicación. Tiene varias funciones específicas, entre las que se incluyen:

1. Proporcionar a la capa de red una interfaz de servicio bien definida.
2. Manejar los errores de transmisión.
3. Regular el flujo de datos para que los emisores rápidos no saturen a los receptores lentos.

Para cumplir con estas metas, la capa de enlace de datos toma los paquetes que obtiene de la capa de red y los encapsula en ***tramas*** para transmitirlos. Cada trama contiene un encabezado, un campo de carga útil para almacenar el paquete y un terminador.
El protocolo de la capa de enlace define el formato de los paquetes intercambiados por los nodos situados en los extremos del enlace, así como las acciones que estos nodos llevan a cabo cuando se envían y reciben los paquetes.
El servicio básico de cualquier capa de enlace es mover un paquete desde un nodo hasta otro adyacente a través de un único enlace de comunicaciones, aunque los detalles del servicio proporcionado pueden variar de un protocolo de la capa de enlace a otro.
Muchos de los servicios proporcionados por la capa de enlace presentan notables paralelismos con los servicios proporcionados en la capa de transporte, no obstante no son lo mismo, ya que están construidos con fines diferentes.

>[!tldr] Implementación de la Capa de Enlace
>En su mayor parte, la capa de enlace se implementa en un adaptador de red, también denominado a veces tarjeta de interfaz de redo simplemente placa de red. El corazón de la tarjeta adaptador de red es el controlador de la capa de enlace, que normalmente es un único chip de propósito especial que implementa muchos de los servicios de la capa de enlace.
>
>![[implementacion-enlace.png]]

## Delimitación de Tramas

Para proveer servicio a la capa de red, la capa de enlace de datos debe utilizar el servicio proporcionado por la capa física, que se encarga de aceptar un flujo de bits puros y tratar de entregarlo al destino. Dividir este flujo de bits en tramas no es una tarea sencilla.
Un buen diseño de tramas debe facilitar al receptor la identificación del inicio de las nuevas tramas, utilizando la menor cantidad posible del ancho de banda del canal. Para esta tarea existen cuatro métodos posibles:

1. **Conteo de bytes**: Utiliza un campo en la cabecera de la trama para indicar el largo en bytes de esta. Cuando la capa de enlace de datos del destino ve el conteo de bytes, sabe dónde concluye la trama. Este método tiene el percance de que este contador puede ser alterado por algún error de transmisión.
2. **Bytes bandera con relleno de bytes**: Se utiliza un byte bandera para indicar el inicio y final de cada trama, con este método dos bytes bandera consecutivos señalan el final de una trama y el inicio de la siguiente. Con el inconveniente de que este byte bandera puede aparecer dentro del contenido de la trama haciendo que se desincronizen todo el envío de datos, una forma de resolver eso es utilizar un byte de escape antes del byte bandera, con la desventaja de que esto produce *overhead* en la trama.
3. **Bits bandera con relleno de bits**: Es muy similar al método anterior con la diferencia que se utiliza una cantidad de bits arbitraria como delimitador. Para evitar que dicho patrón de bits que actúan como delimitador se confunda con los contenidos de la carga útil el receptor al encontrar un patrón similar en el contenido de la trama reemplaza automáticamente el siguiente bit por uno de escape. Es el receptor el que reemplaza esos bits de escape por sus valores originales.
4. **Violaciones de codificación de la capa física**: Utiliza un rango de señales determinada a nivel de hardware para indicar el comienzo y final de la trama. Este método resulta muy práctico ya que como ya existen ciertas señales reservadas se puede encontrar el inicio y final de la trama de forma sencilla sin necesidad de rellenar los datos.

Muchos protocolos de esta capa usan una combinación de estos métodos por seguridad. Por ejemplo un patrón común utilizado para Ethernet y 802.11 es hacer que una trama inicie con un patrón bien definido, conocido como ***preámbulo***, dicho patrón podría ser bastante largo de modo que el receptor se pueda preparar para un paquete entrante. El preámbulo va seguido de un campo de longitud en el encabezado, que se utiliza para localizar el final de la trama.

## Servicios de Transmisión

La capa de enlace de datos puede diseñarse para ofrecer varios servicios. Los servicios reales ofrecidos varían de un protocolo a otro. Tres posibilidades razonables que normalmente se proporcionan son:

1. **Servicio sin conexión ni confirmación de recepción**: La máquina de origen envíe tramas independientes a la máquina de destino sin que ésta confirme la recepción, por lo que no se establece una conexión lógica de antemano. Si se pierde una trama debido a ruido en la línea, en la capa de datos no se realiza ningún intento por detectar la pérdida o recuperarse de ella. Esta clase de servicio es apropiada cuando la tasa de error es muy baja, de modo que la recuperación se deja a las capas superiores.
2. **Servicio sin conexión con confirmación de recepción**: La máquina de origen envía tramas sin establecer una conexión lógica entre los nodos, pero el receptor confirma de manera individual la recepción de cada trama enviada. De esta manera, el emisor sabe si la trama llegó bien o se perdió. Si no ha llegado en un intervalo especificado, se puede enviar de nuevo. Este servicio es útil en canales no confiables, como los de los sistemas inalámbricos.
3. **Servicio orientado a conexión con confirmación de recepción**: Las máquinas de origen y de destino establecen una conexión antes de transferir datos. Cada trama enviada a través de la conexión está numerada, y la capa de enlace de datos garantiza que cada trama enviada llegará a su destino. Garantizando además que cada trama se recibirá exactamente una vez y que todas las tramas se recibirán en el orden correcto.

>[!tldr] Control de Errores
>La forma habitual de asegurar la entrega confiable de datos es proporcionando retroalimentación al emisor sobre el estado en el otro extremo de la línea. Si el emisor recibe una confirmación positiva de recepción de una trama, sabe que la trama llegó correctamente. Por el contrario, una confirmación negativa de recepción indica que algo falló y que la trama debe ser retransmitida.
>Problemas relacionados con el hardware pueden causar la pérdida total o parcial de la trama de control, lo que haría que el emisor espere indefinidamente dicha trama. Para solucionar este problema, se introducen temporizadores en la capa de enlace. Estos temporizadores permiten al emisor esperar un tiempo determinado para recibir la confirmación de recepción. Si no se recibe la confirmación dentro del tiempo establecido por el temporizador, el emisor vuelve a enviar la misma trama.

## Control de Flujo

Otro aspecto importante en el diseño de la capa de enlace de datos es qué hacer con un emisor que quiere transmitir tramas de manera sistemática y a mayor velocidad que aquella con que puede aceptarlos el receptor. Para hacer frente a esta problemática existen dos métodos distintos:

- **Control de flujo basado en retroalimentación**: El receptor envía de regreso información al emisor para autorizarle que envíe más datos o por lo menos indicarle su estado.
- **Control de flujo basado en tasa**: El protocolo de la capa de enlace posee un mecanismo integrado que limita la tasa a la que el emisor puede transmitir los datos, sin recurrir a la retroalimentación por parte del receptor.

### Protocolos de Ventanas Deslizantes

El protocolo de ventana deslizante es un mecanismo de controla el flujo en redes que permite al emisor enviar múltiples tramas antes de necesitar una confirmación (ACK), aumentando la eficiencia. Tanto el emisor como el receptor tienen una "ventana" que indica el número de tramas que se pueden transmitir sin confirmar. El emisor envía un un número $w$  de tramas, cada una con un número de secuencia. El receptor recibe las tramas y envía ACKs para las tramas correctas. Al recibir un ACK, la ventana del emisor se desplaza, permitiendo enviar nuevas tramas.
Tradicionalmente, los datos y tramas de control se enviaban por enlaces físicos separados, lo que era menos eficiente. Ahora, con el uso de conexiones _full-duplex_ o _half-duplex_, las tramas se intercalan en el mismo enlace. Para mejorar la eficiencia, en lugar de enviar una trama de control independiente tras recibir una de datos, el receptor espera a que la capa de red le pase el siguiente paquete de datos, y anexa la confirmación de recepción a esta trama mediante un campo del encabezado. Así, la confirmación viaja con la siguiente trama de datos, optimizando el uso del enlace y reduciendo las tramas de control enviadas. Esta técnica se conoce como ***superposición (piggybacking)***. Por supuesto, si uno de los nodos tiene que enviar una confirmación pero no tiene datos para enviar, se enviará una trama de confirmación.

>[!tldr] Envió de Tramas de Confirmación
>A la hora de enviar ACK al emisor, el receptor no necesita enviar una confirmación para todas las tramas, solo basta con enviar cual es el número de secuencia de la trama que está esperando (Receive Ready).
>La mayoría de los protocolos también permiten que cualquiera de los participantes pueda interrumpir totalmente la transmisión de tramas desde el otro extremo a través de un mensaje especial (Receive Not Ready).

## Control de Errores

El control de errores hace referencia a los mecanismos necesarios para la detección y la corrección de errores que aparecen en una transmisión de tramas. Las técnicas más usuales para el control de errores se basan en algunas o todas las siguientes aproximaciones:

- **Detección de errores**: Consiste en un conjunto de métodos que permiten al emisor detectar si los datos de las tramas están corruptos o no.
- **Confirmaciones positivas**: El destino devuelve una confirmación positiva por cada trama recibida con éxito, libre de errores.
- **Retransmisión tras la expiración de un temporizador**: El emisor retransmite las tramas que no se han confirmado tras un periodo de tiempo predeterminado.
- **Confirmación negativa y retransmisión**: El receptor devuelve una confirmación negativa para aquellas tramas en las que se detecta la ocurrencia de errores. El origen retransmitirá de nuevo dichas tramas.

Estos mecanismos se denominan genéricamente ***solicitud de repetición automática (ARQ)***; el objetivo de estos esquema es convertir un enlace de datos no fiable en fiable. Hay tres variantes ARQ estandarizadas:

1. **ARQ con parada y espera**: El emisor transmite una única trama y espera la confirmación (ACK) antes de enviar otra. Si la confirmación se pierde, un temporizador obliga al emisor a retransmitir la trama para evitar una espera infinita.
2. **ARQ con adelante-atras N**: El emisor envía una serie de tramas numeradas secuencialmente hasta un valor máximo. Si no hay errores en ninguna de las tramas, el receptor confirma las tramas recibidas, en caso contrario, el receptor envía una confirmación negativa (REJ), para posteriormente descartando la trama errónea y todas las siguientes hasta recibir la trama correcta. Al recibir la confirmación negativa, el emisor debe retransmitir la trama errónea y todas las posteriores.
3. **ARQ con rechazo selectivo**: El emisor solo se retransmite las tramas que reciben una confirmación negativa (SREJ) por parte del receptor o aquellas cuyo temporizador haya expirado.

>[!tldr] Eficiencia del Rechazo Selectivo
>El rechazo selectivo puede parecer más eficiente que la adelante-atras-N, ya que minimiza las retransmisiones. Sin embargo, el receptor necesita memoria temporal suficiente para almacenar las tramas posteriores a una SREJ y lógica adicional para reinsertar la trama corregida. Asimismo, el transmisor requiere lógica más compleja para enviar tramas fuera de orden. Estas complicaciones hacen que el rechazo selectivo se use menos que adelante-atras-N, aunque es común en enlaces satelitales debido al alto retardo de propagación.

Existe una relación entre el método de corrección de errores y la cantidad de tramas que se pueden enviar antes de recibir una confirmación en un protocolo de ventana deslizante. En general, para el esquema de adelanto-atrás-N, el tamaño máximo de la ventana es igual a $2^n - 1$. Enviar esta cantidad de tramas simultáneamente evita la colisión de los números de secuencia asignados a cada trama, lo que reduce la posibilidad de enviar tramas incorrectas. En contraste, el esquema de rechazo selectivo permite enviar hasta $2^{n-1}$ tramas simultáneamente. Esta cantidad es más limitada porque es necesario mantener en memoria el resto de las tramas, lo que incrementa la probabilidad de colisiones de números de secuencia si se envían muchas tramas a la vez.

### Técnicas Para la Detección de Errores

Las técnicas de detección y corrección de errores permiten al receptor detectar en ocasiones, pero no siempre, que se han producido errores en los bits. Incluso utilizando bits de detección de errores pueden seguir existiendo errores de bit no detectados. Por tanto, lo que intentaremos será elegir un esquema de detección de errores que haga que la probabilidad de que se produzcan estos casos sea pequeña. Por regla general, cuanto más sofisticadas son las técnicas de detección y corrección de errores mayores son los recursos adicionales necesarios.

#### Comprobación de Paridad

Quizá la forma más simple de detección de errores sea el uso de un único **bit de paridad**, este bit de paridad no es más que un bit adicional que el emisor pone al final de la carga útil de la trama y dependiendo del tipo de paridad elegida la cantidad de unos de la carga útil mas este bit sera par o impar.
La operación del receptor también es muy simple, cuando se utiliza un único bit de paridad el receptor sólo necesita contar el número de unos dentro de los $d + 1$ bits recibidos. Si se está utilizando un esquema de paridad par y se encuentra un número impar de bits con valor 1, el receptor sabrá que se ha producido al menos un error de bit.
Un problema con este esquema es que un bit de paridad sólo puede detectar de manera confiable un error de un solo bit en el bloque. Si el bloque está muy confuso debido a una ráfaga de errores larga, la probabilidad de detectar ese error es sólo de 50%, lo cual es difícilmente aceptable.
Es posible aumentar la probabilidad de manera considerable si cada bloque a enviar se trata como una matriz rectangular de $n \times k$ bits. Ahora, si calculamos y enviamos un bit de paridad para cada fila, se detectarán de manera confiable errores de hasta $k$ bits siempre y cuando haya a lo mucho un error por fila. Esta técnica se puede mejorar aun más si se calculan los bits de paridad sobre los datos en un orden distinto al que se transmiten los bits de datos. A este proceso se le denomina intercalado

>[!tldr] Corrección de Errores hacia Adelante
>La capacidad del receptor para detectar y corregir errores a la vez se conoce con el nombre de ***corrección de errores hacia adelante (FEC)***. Estas técnicas se suelen utilizar comúnmente en los dispositivos de almacenamiento y reproducción de audio, como por ejemplo los CD de audio. En un entorno de red, las técnicas FEC también pueden emplearse por sí mismas o en conjunción con técnicas ARQ.

#### Suma de Comprobación

En las técnicas de suma de comprobación, los $d$ bits de datos se tratan como una secuencia de enteros de $k$ bits. Un método simple de suma de comprobación consiste en sumar estos enteros de $k$ bits y utilizar la suma resultante como bits de detección de errores. Un ejemplo de este método es la ***suma de comprobación de Internet***, el cual es utilizado por protocolos como TCP y UDP, con la diferencia que para calcular esta suma se utilizan otros cálculos adicionales. Cabe aclarar que esta suma de comprobación se puede realizar solo sobre la carga útil, sobre la carga útil y el encabezado o protocolos como XTP calculan dos sumas de comprobación, una para la cabecera y otro para la carga útil.
Los métodos de suma de comprobación son eficientes y simples, pero ofrece una protección débil en algunos casos, precisamente debido a que es una suma simple. Existe una mejora a este método el cual es la ***suma de comprobación de Fletcher*** que incluye un componente posicional, en donde se suma el producto de los datos y su posición con la suma acumulada. Este método ofrece una detección más poderosa de los cambios en la posición de los datos.

#### Comprobación de Redundancia Cíclica

Una técnica detección de errores utilizada ampliamente en las redes de computadoras de hoy día esta basada en los ***códigos de comprobación de redundancia cíclica (CRC)***.
Los códigos CRC operan de la siguiente manera. Considere una secuencia de datos $D$ con una longitud de $d$ bits, que el emisor quiere transmitir. Antes de la transmisión el emisor y el receptor tienen que acordar un patrón $G$ de $r + 1$ bits, conocido como **polinomio generador**. Para un determinada secuencia de datos $D$, el emisor seleccionará $r$ bits adicionales a los que llamaremos $R$, y se los añadirá a $D$, de modo que el patrón de $d + r$ bits resultante sea exactamente divisible por $G$ utilizando aritmética módulo 2. Para realizar el proceso de comprobación de errores, el receptor divide los $d + r$ bits recibidos entre $G$. Si el resto es distinto de cero, el receptor sabrá que se ha producido error; en caso contrario, se aceptarán los datos como correctos.
Cada uno de los estándares de CRC puede detectar ráfagas de errores inferiores a $r + 1$ bits. Además, en las condiciones adecuadas, una ráfaga de longitud superior a $r + 1$ bits será detectada con una probabilidad de $1 – \ 0.5^r$.

### Técnicas Para la Corrección de Errores

Todos las técnicas de corrección de errores agregan cierta redundancia en las tramas enviadas, de esta forma el receptor al detectar un error puede corregir este mismo en ese instante. Entre los código utilizados para la corrección de errores se encuentran los siguientes:

1. **Códigos de Hamming**: Añaden una serie de bits de verificación a los datos para detectar y corregir errores de un solo bit. Utilizan posiciones específicas para los bits de verificación. Sin embargo, estos códigos no pueden corregir errores múltiples y son menos eficaces en entornos con mucho ruido.
2. **Códigos convolucionales binarios**: Codifican una secuencia de bits de entrada en una secuencia de bits de salida utilizando una memoria deslizante. La salida depende de los bits actuales y anteriores. La decodificación puede ser compleja y requiere más potencia de procesamiento, especialmente para correcciones en tiempo real.
3. **Códigos de Reed-Solomon**: Operan sobre símbolos de múltiples bits y son efectivos para corregir errores en ráfaga. Utilizan polinomios sobre campos finitos para la corrección. A pesar de su mayor complejidad computacional y matemáticas más complicadas, no son tan efectivos para errores aislados como los códigos de Hamming.
4. **Códigos de verificación de paridad de baja densidad (LDPC)**: Utilizan una matriz de paridad con baja densidad de unos para la detección y corrección de errores, la decodificación en este método se realiza a través de algoritmos iterativos. La decodificación puede ser intensiva en términos de procesamiento y memoria, aunque los algoritmos optimizados han mejorado su rendimiento.

Cada uno de estos métodos tiene sus fortalezas y debilidades, y su elección depende de las necesidades específicas del sistema de comunicación y del tipo de errores esperados. Cabe aclarar que la retransmisión de tramas por parte del emisor sigue siendo un método factible en la mayoría de los casos para la corrección de errores.